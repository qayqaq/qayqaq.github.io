<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>django的视图</title>
      <link href="/2020/08/02/django-de-shi-tu/"/>
      <url>/2020/08/02/django-de-shi-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="视图的功能"><a href="#视图的功能" class="headerlink" title="视图的功能"></a>视图的功能</h2><p>接受请求，进行处理，与 M 和 T 进行交互，返回应答。</p><p>（1）返回 html 内容<code>HttpResponse</code>；</p><p>（2）重定向<code>redirect</code>。</p><h2 id="视图函数的使用"><a href="#视图函数的使用" class="headerlink" title="视图函数的使用"></a>视图函数的使用</h2><p>（1）定义视图函数：<code>request</code>参数必须有。是一个<code>HttpResponse</code>类型的对象。参数名可以变化，但不要更改。</p><p>（2）配置 url，具体见基本应用。</p><h2 id="错误视图"><a href="#错误视图" class="headerlink" title="错误视图"></a>错误视图</h2><p>（1）<strong>404</strong>：<strong>url没有配置或配置错误</strong>找不到页面，关闭调试模式之后，默认会显示一个标准的错误页面，如果要显示自定义页面，则需要在 templates 目录下面自定义一个 404.html 文件</p><p>（2）<strong>500</strong>：<strong>视图出错</strong>服务器端的错误。</p><h2 id="捕获-url-参数"><a href="#捕获-url-参数" class="headerlink" title="捕获 url 参数"></a>捕获 url 参数</h2><p>进行 url 匹配时，把所需要捕获的部分设置成一个<strong>正则表达式组</strong>，这样就会自动把匹配成功后相应组的内容作为参数传递给视图函数。</p><p>（1）<strong>位置参数</strong>：参数名可以随意指定。<code>url(r&#39;^showarg(\d+)&#39;, views.show_arg)</code></p><p>（2）<strong>关键字参数</strong>：在位置参数的基础上给正则表达式组命名即可。<code>url(r&#39;^showarg(?P&lt;num&gt;\d+)&#39;, views.show_arg)</code></p><p>注：？P&lt;组名&gt;，<strong>关键字参数，视图中参数名必须与正则表达式组名一致。</strong></p><h2 id="request-的常用参数"><a href="#request-的常用参数" class="headerlink" title="request 的常用参数"></a>request 的常用参数</h2><p>以下除非特别声明，否则都是只读的。</p><ul><li><code>path</code>: 一个字符串，表示请求的页面的完整路径，不包含域名和参数部分；</li><li><code>method</code>: 一个字符串，表示是 GET 还是 POST；<ul><li>在浏览器中<strong>给出地址</strong>发出请求采用 GET，如超链接；</li><li>在浏览器中<strong>提交表单</strong>发起请求，若表单设置为 POST，则为POST；</li></ul></li><li><code>GET</code>: <code>QueryDict</code>类型对象，类似于字典，包含 get 请求方式所有参数；</li><li><code>POST</code>: <code>QueryDict</code>类型对象，类似于字典，包含 post 请求方式所有参数；</li><li><code>FILES</code>: 一个类似于字典的对象，包含所有上传的文件；</li><li><code>COOKIES</code>: 一个标准的 Python 字典，包含所有的 cookie，键和值都为ie字符串；</li><li><code>session</code>: 一个既可读又可写的类似于字典的对象，表示当前的会话，只有当 django 启用会话的支持时才可用，详细内容后面叙述。</li></ul><p>注：<code>QueryDict</code>可以一个键对应多个值，get方法只会取这个键的最后一个值，getlist方法取出所有。</p><p>给一个提交表单发出请求的实例：</p><pre><code># views.pydef login(request):    return render(request, &#39;booktest/login.html&#39;)def login_check(request):    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# urls.pyurlpatterns = [    url(r&#39;^login$&#39;, views.login),    url(r&#39;^login_check$&#39;, views.login_check),]# login.html&lt;form method=&quot;post&quot; action=&quot;/login_check&quot;&gt;    USERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    PASSWORD&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;</code></pre><h2 id="状态保持——Cookie"><a href="#状态保持——Cookie" class="headerlink" title="状态保持——Cookie"></a>状态保持——Cookie</h2><p>http协议是无状态的，下一次去访问一个页面时并不知道上一次对这个页面作了什么。而使用Cookie就是类似达到一种保存的功能，本质上cookie是<strong>由服务器生成，存储在浏览器的一小段文本信息</strong>。</p><p>想像你去饭店点菜，点完之后就去网吧玩了，打算估摸菜好了再回来吃；而老板很笨，记不住你点了什么菜，所以老板决定给你发一个小票上面记录了你要吃的所有东西并要求回来时带着小票这样老板就知道你要吃的是什么了。</p><p>在这个过程中，老板在你点菜之后给你小票，就是浏览器像服务器发起请求之后，web服务器生成Cookie信息然后让浏览器保存Cookie信息，再带着小票来，就是浏览器再把cookie发送给服务器，这基本上就是cookie的过程。</p><p>cookie 的特点：</p><p>（1）以<strong>键值对</strong>方式进行存储；</p><p>（2）通过浏览器访问一个网站时，会将浏览器存储的和这个网站相关的<strong>所有cookie信息</strong>发送给该网站的服务器，即<code>request.COOKIES</code>；</p><p>（3）cookie是基于域名安全的；</p><p>（4）cookie是有过期时间的，如果不指定，默认关闭浏览器之后cookie就会过期；</p><p>（5）cookie 无论保存什么值，<strong>取出时都是字符串。</strong></p><p>cookie 的设置：需要一个<code>HttpResponse</code>类的对象，或者是它的子类，<code>HttpReponseRedirect</code>，<code>JsonResponse</code>。可以通过<code>max_age</code>和<code>expires</code>参数设置过期时间。</p><pre><code># views.pydef set_cookie(request):    response = HttpResponse(&#39;set cookie&#39;, max_age=14*24*3600)    # response = HttpResponse(&#39;set cookie&#39;, expires=datetime.now()+timedelta(days=14))    response.set_cookie(&#39;num&#39;, 1)    return responsedef get_cookie(request):    num = request.COOKIES[&#39;num&#39;]    return HttpResponse(num)# urls.pyurlpatterns = [    url(r&#39;^set_cookie$&#39;, views.set_cookie),    url(r&#39;^get_cookie$&#39;, views.get_cookie),]</code></pre><p>在上述登录例子基础上，利用Cookie可以方便地实现<strong>记住用户名</strong>这一功能，只需要在登陆成功后设置cookie，再次显示页面时拿出cookie，并在html页面上设置value值显示即可：</p><pre><code># views.pydef login(request):    if &#39;username&#39; in request.COOKIES:        username = request.COOKIES[&#39;username&#39;]    else:        username = &#39;&#39;    return render(request, &#39;booktest/login.html&#39;, {&#39;username&#39;:username})def login_check(request):    # request.POST    # request.GET    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    remember = request.POST.get(&#39;remember&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        response = redirect(&#39;/index&#39;)        if remember == &#39;on&#39;:            response.set_cookie(&#39;username&#39;, username, max_age=7*24*3600)        return response        # return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# login.htmlUSERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ username }}&quot;&gt;&lt;br&gt;</code></pre><h2 id="状态保持——Session"><a href="#状态保持——Session" class="headerlink" title="状态保持——Session"></a>状态保持——Session</h2><p>想象你去网吧办了一张会员卡，网管给了你一个卡号，然后把你的姓名身份证等信息存储到了网吧电脑的表格里。</p><p>在django中，网吧电脑的表格就是 django_session，这个表格类似于字典，每一个主键对应一些信息，给你的卡号即是主键 session_key，电脑里存下的信息就是 session_data，而网馆给了你一个卡号，其实是服务器给浏览器设置了一个 cookie，这个 cookie 名叫<code>sessionid</code>，是读取session信息的惟一标识码，等再次访问网站时，浏览器获取 sessionid，并根据 sessionid 的值取出对应的 session 信息。而这些信息都在<code>request.session</code>属性中。 </p><p>session 的特点：</p><p>（1）session 是以<strong>键值对</strong>进行存储的；</p><p>（2）session 依赖于 cookie，因为 sessionid 是 cookie；</p><p>（3）也有过期时间，不指定的话，默认两周过期。</p><p>（4）不像 cookie， session <strong>保存进去什么类型，取出就是什么类型.</strong></p><p>（5）session涉及到安全性要求比较高的数据，银行卡密码，账户等。相对而言，cookie安全性要求不高，可以记住用户名。</p><ul><li>session 的设置：<code>request.session[&#39;key&#39;] = value</code></li><li>根据键读取：<code>request.session.get(&#39;key&#39;, default)</code></li><li>清除所有session，在存储中删除值部分：<code>request.session.clear()</code></li><li>清除所有session，在存储中删除session整条数据：<code>request.session.flush()</code></li><li>删除session中指定键和值：<code>del request.session[&#39;key&#39;]</code></li><li>设置会话过期时间：<code>request.session.set_expiry(value)</code><ul><li>value是整数，将在value秒没有活动后过期；</li><li>value是0，将在浏览器关闭时过期；</li><li>value是None，将在两周后过期。</li></ul></li></ul><p>在上述登录例子基础上，利用session可以方便地实现<strong>记住登陆状态</strong>这一功能，只需要在登陆成功后设置session的一个键<code>islogin</code>，再次发出登陆情请求时，如果session表格里由<code>islogin</code>这个键，直接显示登陆成功的页面：</p><pre><code># def login_checkif username == &#39;smart&#39; and password ==&#39;123&#39;:    request.session[&#39;islogin&#39;] = True        return response# def loginif request.session.has_key[&#39;islogin&#39;]:    return redirect(&#39;/index&#39;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> django， Cookie， Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的模型</title>
      <link href="/2020/08/02/django-de-mo-xing/"/>
      <url>/2020/08/02/django-de-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="字段属性和选项："><a href="#字段属性和选项：" class="headerlink" title="字段属性和选项："></a>字段属性和选项：</h2><p>列举部分常用的，其余参考官方文档。</p><p>字段类型，使用时需要引入 django.db.models：</p><ul><li><code>Autofield</code>: 自增的，不用指定；</li><li><code>BooleanField</code>: 布尔；</li><li><code>NullBooleanField</code>: 支持 Null 的布尔；</li><li><code>CharField(max_length=)</code>: 字符串；</li><li><code>TextField</code>: 大文本字段，超过4000字；</li><li><code>IntegerField</code>: 整数；</li><li><code>DecimalFIeld(max_digits=None,decimal_places=None)</code>: 十进制浮点数；</li><li><code>FloatField</code>：浮点数，参数同上，没有 Deciaml 精确；</li><li><code>DateField([auto_now=False, auto_now_add=False])</code>: 日期，auto_now 会自动更新最后一次修改数据时间，auto_now_add 会自动添加创建数据时的时间，不可同时使用；</li><li><code>TimeField</code>: 时间，参数同上；</li><li><code>DateTimeField</code>: 日期时间，参数同上；</li><li><code>FileField</code>: 上传文字字段；</li><li><code>ImageField</code>: 继承于 FileField，对上传内容进行校验，确保是有效的图片。</li></ul><p>选项：</p><ul><li><code>default</code>: 设置默认值；</li><li><code>primary_key</code>: 设为主键，默认 False；</li><li><code>unique</code>: 字段在表中必须有唯一值，默认 False；</li><li><code>db_index</code>: 在表中会为此字段创建索引，默认 False；</li><li><code>db_column</code>: 字段名称，如未指定，则使用属性名称；</li><li><code>null</code>: 允许为空，默认 False；</li><li><code>blank</code>: 允许为空白，默认 False；</li></ul><p>注： null是数据库范畴的概念，blank 是后台管理页面表单验证范畴的。</p><p>当修改模型类之后，如果添加的选项不影响表的结构，则不需要重新迁移，default 和 blank 不影响表的结构。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><strong>查询函数：</strong></p><p>通过模型类<code>.objects</code>属性可以调用如下函数，实现对模型类对应的数据表的查询。</p><ul><li><p><code>get</code>: 返回一个模型类对象，参数写查询条件，查不到或者查到多条都会报错；</p></li><li><p><code>all</code>: 返回<code>QuerySet</code>类型； </p></li><li><p><code>filter</code>: 返回<code>QuerySet</code>类型，参数写查询条件； </p></li><li><p><code>exclude</code>: 同上；</p></li><li><p><code>order_by</code>: 返回<code>QuerySet</code>类型，参数写属性，默认从小到大排序，在属性前加‘-’为从大到小；</p><p>  <code>BookInfo.objects.order_by(&#39;-id&#39;)</code></p></li></ul><p><strong>查询条件：</strong></p><p>条件格式：模式类属性名__<strong>条件名</strong>=值</p><ul><li><p>判等 条件名：exact（可省略）<code>BookInfo.objects.get(id__exact=1)</code></p></li><li><p>模糊查询 条件名：contains（包含）endswith（结尾）startswith（开头）<code>BookInfo.objects.filter(btitle__contains=&#39;三&#39;)</code></p></li><li><p>空查询 条件名：isnull <code>BookInfo.objects.filter(id__isnull=False)</code></p></li><li><p>范围查询 条件名：in <code>BookInfo.objects.filter(id__in=[1,3,5])</code></p></li><li><p>比较查询 条件名：gt，lt，gte，lte </p><p>  id大于等于3：<code>BookInfo.objects.filter(id__gte=3)</code></p></li><li><p>日期查询</p><p>  1999年出版：<code>BookInfo.objects.filter(bupdate__year=1999)</code><br>  1980.1.1后出版：<code>BookInfo.objects.filter(bupdate__gt=date(1980,1,1))</code></p></li></ul><h2 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h2><p>作用：用于查询时条件之间的<strong>逻辑关系</strong>。not and or，可用Q对象进行&amp;|～操作。若不使用Q对象，默认写多个条件是且关系。</p><pre><code>from django.db.models import QBookInfo.objects.filter(id__gt=3，bread__gt=30)BookInfo.objects.filter(Q(id__gt=3)|Q(bread__gt=30))BookInfo.objects.filter(～Q(id=3))</code></pre><h2 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h2><p>作用：用于类属性之间的比较。</p><pre><code>from django.db.models import FBookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;))BookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;)*2)</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>作用：对查询结果进行聚合操作。sum count avg max min。调用 aggregate 来聚合，返回一个字典。</p><pre><code>from django.db.models import Sum, Count, Avg, Max, MinBookInfo.objects.all().aggregate(Count(&#39;id&#39;))# {&#39;id__count&#39;: 5}BookInfo.objects.all().aggregate(Sum(&#39;bread&#39;))# {&#39;bread__sum&#39;: 126}</code></pre><p><strong>count</strong>函数返回值是一个数字，也可以统计满足条件数据的数目。</p><pre><code>BookInfo.objects.all().count()BookInfo.objects.count()</code></pre><h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>对一个QuerySet对象，以上函数都可以继续使用。</p><p><strong>查询集特性：</strong></p><ul><li><strong>惰性查询：</strong>只有在实际使用查询集中的数据时才会发生对数据库的真正查询。</li><li><strong>缓存：</strong>当使用的是同一个查询集时，第一次的时候会发生实际数据库的查询。然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。</li></ul><p><strong>限制查询集：</strong><br>可以对一个查询集进行取下标或者切片来限制查询集的结果。</p><p>对一个查询集进行切片会产生<strong>新查询集</strong>，下标<strong>不允许为负数</strong>。</p><p>取出查询集第一条数据：</p><ul><li><code>b[0]</code> 若不存在，报 <code>IndexError</code></li><li><code>b[0:1]</code>.get() 若不存在，报 <code>DoesNotExist</code></li></ul><p>查询集的<strong>exists</strong>方法可以判断是否有数据。</p><h2 id="模型类关系"><a href="#模型类关系" class="headerlink" title="模型类关系"></a>模型类关系</h2><ul><li>多对多：<code>models.ManyToManyField()</code>，定义在哪都行；</li><li>一对一：<code>models.OneToOneField()</code>，定义在哪都行；</li><li>一对多：<code>models.ForeignKey()</code>，定义在多类中。</li></ul><p><strong>一对多的关联查询</strong></p><ul><li>用实例查询：<ul><li>由多查一：<code>h.hbook</code></li><li>由多查一的对象的id：<code>h.hbook_id</code></li><li>由一查多：<code>book.heroinfo_set.all()</code></li></ul></li><li>用模型类实现关联查询<ul><li>通过多类的条件查询一类的数据：<pre><code>  # 一类名.objects.filter(多类名小写__多类名属性__条件名)  BookInfo.objects.filter(heroinfo__hcomment__contains=&#39;丁&#39;)</code></pre></li><li>通过一类的条件查询多类的数据：<pre><code>  # 多类名.objects.filter(关联属性__一类名属性__条件名)  HeroInfo.objects.afilter(hbook__btitle=&#39;三体&#39;)</code></pre></li></ul></li></ul><h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><p>外键指向自身的属性，在查询时仍然按照一对多的关系查询。</p><pre><code># models.pyclass AreaInfo(model.Models):    atitle = model.CharFields(max_length=20)    aParent = models.Foreign(&#39;self&#39;, null=True, blank=True)# views.pydef areas(request):    area = AreaInfo.objects.get(atitle=&#39;广州&#39;)    parent = area.aParent    children = area.areainfo_set.all()</code></pre><h2 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h2><p>我们在查询中一直使用的 objects 其实是 django 自动生成的管理器 models.Manager() 类对象，我们也可以自定义，但是自定义管理器之后，django 便不会再自己生成 objects 管理器。</p><p>自定义分为两步：</p><p>（1）自定义一个管理器类，继承于 models.Manager()</p><p>（2）在具体的模型类中定义一个管理器类的对象。</p><p>自定义管理器类的应用场景：</p><p>（1）改变查询的结果集，比如调用 all 返回的是没有删除的图书的数据。</p><pre><code>class BookInfoManager(models.Manager):    def all(self):        books = super().all()        books = books.filter(isDelete=False)        return booksclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><p>（2）添加额外的方法使我们操作模型类对应的数据表。使用 self.model() 就可以创建一个根自定义管理器对应的模型类对象，这样作可以防止因为改换模型类的名字而相应也要改换管理器中的名字，避免了麻烦。</p><pre><code>class BookInfoManager(models.Manager):    def create_book(self, btitle, bupdate):        model_class = self.model        book = model_class()        book.btitle = btitle        book.bupdate = bupdate        book.save()        return bookclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><h2 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h2><p>django 默认生成的表名：<strong>应用名小写__模型类名小写</strong></p><p>元选项：需要在模型类中定义一个元类<code>Meta</code>，在里买年定义一个类属性 <code>db_table</code>就可以指定表名</p><pre><code>class BookInfo(model.Models):    class Meta:        db_table = &#39;new_sheet_name&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的基本应用</title>
      <link href="/2020/07/30/django-de-ji-ben-ying-yong/"/>
      <url>/2020/07/30/django-de-ji-ben-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="项目与应用创建"><a href="#项目与应用创建" class="headerlink" title="项目与应用创建"></a>项目与应用创建</h2><pre><code>django-admin startproject test1  # 创建 test1 项目python37 manage.py startapp booktest  # 创建 booktest 应用</code></pre><ul><li>项目目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>settings.py</code> 项目的配置文件；</li><li><code>urls.py</code> 进行 url 路由的配置；</li><li><code>wsgi.py</code> web 服务器和 Django 交互的入口</li><li><code>manage.py</code> 项目的管理文件。</li></ol></li><li>应用目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>model.py</code> 写和数据库相关的功能；</li><li><code>views.py</code> 接受请求，进行处理，与 M 和 T 进行交互，返回应答，定义处理函数，称为视图函数；</li><li><code>test.py</code> 写测试代码的文件；</li><li><code>admin.py</code> 网站后台管理相关的文件</li></ol></li></ul><p>还需要建立应用与项目之间的联系，需要对应用进行注册。<br>修改<code>settings.py</code>中的 INSTALLED_APPS 配置项，加入自己的应用名称即可。</p><pre><code>INSTALLED_APPS = (    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;booktest&#39;,  # 注册应用)</code></pre><h2 id="配置-mysql-数据库"><a href="#配置-mysql-数据库" class="headerlink" title="配置 mysql 数据库"></a>配置 mysql 数据库</h2><p>Django 自带的数据库是 sqlite 相对小型，在大项目中用的更多的是 oracle 和 mysql，所以要替换。</p><p>模型是对数据库的相关操作，利用 Django 配置 mysql 数据库，需要修改<code>settings.py</code>中的 DATABASE。</p><pre><code>DATABASES = {    &#39;default&#39;: {        # &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,          # &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),        &#39;NAME&#39;: &#39;qay&#39;,            # 数据库名称        &#39;USER&#39;: &#39;root&#39;,           # 登陆数据库的用户名        &#39;PASSWORD&#39;: &#39;qin200053&#39;,  # 登陆密码        &#39;HOST&#39;: &#39;localhost&#39;,      # 登陆地址        &#39;PORT&#39;: &#39;3306&#39;,           # 端口号，mysql默认端口号是3306    }}</code></pre><p>注意：django不会生成数据库，需要我们自己创建。</p><p>我的 Ubuntu 版本是20.04，mysql官网上只有8.0才支持20.04，于是我直接安装的 mariadb 暂时作为 mysql 的替代品，目前看来命令没什么区别，希望以后不会出什么bug。</p><pre><code>sudo apt-get mariadb-server mariadb-client  # 安装</code></pre><ul><li>开启关闭服务，登陆退出。<pre><code>  sercive mysql start  service mysql stop  sudo mysql -uroot </code></pre></li><li>避免使用 sudo 登陆,需要执行<code>sudo vim /etc/mysql/my.cnf</code>，然后添加如下语句，再重启服务即可。<pre><code>  [mysqld]  skip-grant-tables</code></pre></li><li>修改mysql密码。<pre><code>  mysql -uroot -p  use mysql   update user set authentication_string=password(&#39;xxxxxx&#39;) where User=&#39;root&#39;;</code></pre></li><li>创建新的数据库<pre><code>  mysql -uroot -p  show databases;  create database qay charset=utf8;  show databases; </code></pre></li></ul><p>处理完 mysql，在启动项目之前，需要<code>sudo pip37 install pymysql</code>，并在项目的<code>__init__.py</code>中加入如下语句，就可以了。</p><pre><code>import pymysqlpymysql.install_as_MySQLdb()</code></pre><h2 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h2><p>我们需要设计和数据库中表相对应的类，称为模型类，本质上就是在<code>models.py</code>中建立 class，其必须继承于 models.Model类。</p><pre><code>class BookInfo(models.Model):    &#39;&#39;&#39;图书模型类&#39;&#39;&#39;    # 图书名称，字符串，最长20    btitle = models.CharField(max_length=20)    # 出版日期，日期类型    bupdate = models.DateField()</code></pre><p>设计完模型类之后，将其生成为数据库中的表：</p><ul><li><p>生成迁移文件<code>python37 manage.py makemigrations</code>，文件生成在 migrations 文件夹中；</p></li><li><p>执行迁移生成表<code>python37 manage.py migrate</code>，这样去数据库里就能查看到了，创建的表名即为<code>应用名_类名</code>。</p></li><li><p>接下来就可以通过python语句，对数据进行操作了，利用 <code>python37 manage.py shell</code>进行操作：</p><pre><code>  &gt;&gt;&gt; from booktest.models import BookInfo  &gt;&gt;&gt; b = BookInfo()  &gt;&gt;&gt; b.btitle = &#39;三体&#39;  &gt;&gt;&gt; from datetime import date  &gt;&gt;&gt; b.bupdate = date(1990,1,1)  &gt;&gt;&gt; b.save()  # 通过 save 进行插入和修改  &gt;&gt;&gt; b_all = BookInfo.objects.all()   # 拿到所有实例，即表中所有条目，返回一个列表  &gt;&gt;&gt; b2 = BookInfo.objects.get(id=1)  # 拿到实例，可以借此查询  &gt;&gt;&gt; b_cond = BookInfo.objects.get(btitle=&#39;三体&#39;)  # 按条件查询  &gt;&gt;&gt; type(b2)  &lt;class &#39;booktest.models.BookInfo&#39;&gt;  &gt;&gt;&gt; b2.btitle  &#39;三体&#39;  &gt;&gt;&gt; b2.bupdate  datetime.date(1990,1,1)  &gt;&gt;&gt; b2.delete()  # 通过 delete 删除</code></pre></li></ul><pre><code>class HeroInfo(models.Model):    hname = models.CharField(max_length=20)    hgender = models.BooleanField(default=False)    hcomment = models.CharField(max_length=128)    # 关系属性 hbook，建立图书类和英雄人物类之间的一对多关系    hbook = models.ForeignKey(&#39;BookInfo&#39;)</code></pre><p>表之间存在关系。</p><ul><li><p>Models.ForeignKey 可以建立两个模型之间一对多的关系，django 在生成表的时候，就会在多的表中创建一列作为外键，建立两个表之间一对多的关系。关系属性对应的表的字段名格式为<code>关系属性名_id</code>。</p><p>  以上面的类作为例子，很多英雄可能都属于一本书，所以在‘多类’中添加关系属性，赋值时要赋‘一类’的实例，在实际的表中，<code>h</code>的属性<code>hbook_id</code>的值即为<code>b</code>的主键<code>id</code>值：</p><pre><code>  b = BookInfo()  h = HeroInfo()  h.hbook = b</code></pre></li><li><p>建立了关系之后，可以根据关系查询：</p><p>  由一查多：<code>b.heroinfo_set.all()</code><br>  由多查一：<code>h.hbook</code></p></li></ul><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><ul><li><p>修改<code>settings.py</code>，语言和时区本地化</p><pre><code>  LANGUAGE_CODE = &#39;zh_hans&#39;  TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre></li><li><p>创建管理员</p><pre><code>  python37 manage.py createsuperuser</code></pre></li><li><p>在<code>admin.py</code>中注册模型类</p><pre><code>  admin.site.register(BookInfo)  admin.site.register(HeroInfo)</code></pre></li><li><p>启动项目后在浏览器输入<code>http://127.0.0.1:8000/admnin</code></p></li><li><p>自定义管理页面，在 admin 中建立自定义管理类</p><pre><code>  class BookInfoAdmin(admin.ModelAdmin):      list_display = [&#39;id&#39;,&#39;btitle&#39;,&#39;bupdate&#39;]  admin.site.register(BookInfo, BookInfoAdmin)</code></pre></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在 Django 中，通过浏览器去请求一个页面时，使用视图函数来处理这个请求，视图函数处理之后，要给浏览器返回页面内容。</p><ul><li><p>在<code>views.py</code>中定义视图函数</p><p>  视图函数必须有一个参数<code>request</code>，处理之后需要返回一个 HttpResponse 的类对象。</p><pre><code>  # http://127.0.0.1:8000/index  def index(request):      return HttpResponse(&quot;nb!&quot;)</code></pre></li><li><p>配置项目路由</p><pre><code>  urlpatterns = [      url(r&#39;^admin/&#39;, include(admin.site.urls)),      url(r&#39;^&#39;, include(&#39;booktest.urls&#39;)),  ]</code></pre></li><li><p>配置应用路由，需要自己在应用目录下创建<code>urls.py</code></p><pre><code>  urlpatterns = [      url(r&#39;index$&#39;, views.index),  ]</code></pre></li><li><p>路由匹配过程</p><p>  当浏览器中输入<code>http://127.0.0.1:8000/index</code>，会自动除去前面的<code>http://127.0.0.1:8000/</code>用剩下的部分进行匹配，这里即<code>index</code>，先根据项目路由中的<code>urlpatterns</code>从上到下匹配，匹配成功后，根据后面的<code>include()</code>确定下一部去哪个应用进行匹配，这里即<code>booktest.urls</code>，然后再到<code>urlpatterns</code>从上到下匹配，直到匹配成功为止。</p><p>  匹配时严格根据正则规则匹配。（在新版本的django中函数 url 改成了函数 path，已经不需要正则表达式了）</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>创建模板文件夹<code>templates</code>,并在<code>settings.py</code>的 TEMPLATES 中配置模板目录，通常可能有很多应用，所以在<code>templates</code>再以应用名建立文件夹<code>booktest</code><pre><code>  &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],</code></pre></li><li>使用模板文件分为三步：<ol><li>加载模板文件：去模板目录下获取html文件内容，得到一个模板对象；</li><li>定义模板上下文：像模板文件传递数据，传递时以键值对形式传递；</li><li>模板渲染：得到一个标准的html内容。<pre><code>def my_render(request, template_path, context_dict): temp = loader.get_template(&#39;booktest/index.html&#39;) context = RequestContext(request, {})  # 这里传了空字典 res_html = temp.render(context) return HttpResponse(res_html)</code></pre></li><li>以上三步可以用一个函数<code>render</code>完成:<pre><code>def index(request): # 传了两个变量，一个字符串一个列表 return render(request, &#39;booktest/index.html&#39;,           {&#39;content&#39;:&#39;hello world&#39;,&#39;list&#39;:list(range(1,10))})  </code></pre></li></ol></li><li>模板文件不仅仅时一个html文件，可以说有自己的语法，变量需要用两组花括号包裹，循环遍历或判断要用花括号和百分号包裹，下面给出一个例子：<pre><code>  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;mplate file&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;h1&gt;this is a template file&lt;/h1&gt;      use the template variable: &lt;br&gt;      {{ content }} &lt;br&gt;      use the list: &lt;br&gt;      {{ list }} &lt;br&gt;      for loop: &lt;br&gt;      &lt;ul&gt;          {% for i in list %}                &lt;li&gt;{{ i }}&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre></li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在视图函数的返回中，可以返回给定的一个模板，也可以根据 url 返回到另一个网址，这种就叫做重定向，下面就是在页面上显示书籍之后，新增或删除书籍之后仍返回 index 页面的例子，其中redirect 就是 HttpResponseRedirect 的一个简写。</p><p>注意，在html中有重定向，写到了链接时，为避免出错字符串要以<code>/</code>开头。</p><pre><code>def create(request):    b = BookInfo()    b.btitle = &#39;乡村教师&#39;    b.bupdate = date(1999,9,9)    b.save()    # return HttpResponse(&#39;ok&#39;)    return HttpResponseRedirect(&#39;/indexx&#39;)def delete(request, bid):    b = BookInfo.objects.get(id=bid)    b.delete()    return redirect(&#39;/indexx&#39;)</code></pre><h2 id="很简单的一个实例"><a href="#很简单的一个实例" class="headerlink" title="很简单的一个实例"></a>很简单的一个实例</h2><p>做一个很简单的实例，输入<code>http://127.0.0.1:8000/books</code>进入页面显示书名，点击书名能跳转到书所包含的人物信息。</p><ul><li><p>最重要的就是设计视图函数</p><pre><code>  def show_books(request):      books = BookInfo.objects.all()      return render(request, &#39;booktest/show_books.html&#39;,                  {&#39;books&#39;:books})  def detail(request, bid):      book = BookInfo.objects.get(id=bid)      heros = book.heroinfo_set.all()      return render(request, &#39;booktest/detail.html&#39;,          {&#39;book&#39;:book, &#39;heros&#39;:heros})</code></pre></li><li><p>配置各个页面的路由</p><pre><code>  urlpatterns = [      url(r&#39;^books$&#39;, views.show_books),      url(r&#39;^books/(\d+)$&#39;, views.detail),  ]</code></pre></li><li><p>编写模板呈现页面</p><pre><code>      # show_books.html      Information of Book is Followed:      &lt;ul&gt;          {% for book in books %}            &lt;li&gt;&lt;a href="/books/{{ book.id }}"&gt;{{ book.btitle }}&lt;/a&gt;&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;      # detail.html      &lt;h1&gt;{{ book.btitle }}&lt;/h1&gt;      Information of Heros is Followed:&lt;br&gt;      &lt;ul&gt;          {% for hero in heros %}                &lt;li&gt;{{ hero.hname }}--{{ hero.hcomment }}&lt;/li&gt;            {% empty %}                &lt;li&gt;no Information of Hero&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  </code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从集群的部署</title>
      <link href="/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/"/>
      <url>/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>主从，直观来说就是备份，当一个 redis 服务挂掉时，为了防止数据丢失或者不能使用，有一个副本来代替原来的服务。</p><h3 id="配置主"><a href="#配置主" class="headerlink" title="配置主"></a>配置主</h3><ul><li>查看当前主机 ip 地址 <code>ifconfig</code></li><li>修改 redis.conf 中的 bind <code>bind 192.168.xx.xx</code></li><li>重启 redis 服务 <code>redis-server redis.conf</code></li></ul><h3 id="配置从"><a href="#配置从" class="headerlink" title="配置从"></a>配置从</h3><ul><li>复制 redis.conf <code>sudo cp redis.conf ./slave.conf</code></li><li>修改 slave.conf 文件 <code>sudo vim slave.conf</code></li><li>编辑如下内容，注意端口号不能和主重复<pre><code>  bind 192.168.xx.xx  slaveof 192.168.xx.xx 6379  # 这是额外添加的一项  port 6378</code></pre></li><li>启动从服务 <code>sudo redis-server save.conf</code></li><li>查看主从关系 <code>redis-cli -h 192.168.xx.xx info Replication</code></li></ul><h3 id="主从配置下数据操作"><a href="#主从配置下数据操作" class="headerlink" title="主从配置下数据操作"></a>主从配置下数据操作</h3><p>与正常基本没有区别。</p><p>在主和从分别执行 info 命令查看输出信息后，进入主客户端，写数据；这时进入从客户端就可以读数据了。</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>集群，直观来讲就是好多 redis 服务作为一个整体对外工作，人多力量大。</p><p>集群分为两种，一种是软件集群，即只有一台电脑上面开启了很多 redis 服务，将这些服务集群；另一种是硬件集群，即有很多电脑，每台电脑上都有一个或很多 redis 服务，将所有服务集群。</p><p>集群中的主节点负责处理槽（存储数据），从节点则是主节点的复制品；</p><p>Redis集群将整个数据库分成16384个槽，数据库中的每个键都属于16384个槽中的其中一个；</p><p>集群中的每个主节点都可以负责0到16384个槽，当16384个槽都有节点在负责时，集群进入上线状态，可以执行客户端发送的数据命令；</p><p>可以在 conf 文件中更改槽的总数。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>试验时，在本机上开启6个服务做集群。</p><ul><li>创建 conf 目录</li><li>在 conf 目录下创建 7000.conf，编辑内容如下：<pre><code>  port 7000  bind 192.168.xx.xx  daemonize yes  # 作为守护进程运行  pidfile 7000.pid  # 运行后进程 id 写入这里  cluster-enabled yes  # 可以作为集群的节点  cluster-config-file 7000_node.conf  # 集群节点的配置文件  cluster-node-timeout 15000  # 连接集群节点的超时时间  appendonly yes  # 数据文件可追加</code></pre></li><li>同理创建7001，7002，7003，7004，7005</li><li>开启6个服务</li><li>用 redis-trib.rb 命令就可以创建集群，命令在源码包的 src 下，可以通过 cp 复制到 /usr/local/bin<pre><code>  redis-trib.rb create --replicas 1 192.168.101.145:7000 192.168.101.145:7001 192.168.101.145:7002 192.168.101.145:7003 192.168.101.145:7004 192.168.101.145:7005</code></pre></li></ul><p>如果没有报错，则说明集群建立成功了。</p><p>如果报错了。说明 ruby 的最新版本，按照如下方法解决。</p><pre><code>$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB$ curl -sSL https://get.rvm.io | bash -s stable$ source ~/.bashrc$ source ~/.bash_profile$ rvm list known$ rvm install 2.7.1 --disable-binary$ rvm use 2.7.1 --default$ rvm list$ gem install redis  # 最后安装 redis 集群接口</code></pre><p>执行完以上代码之后，再执行 redis-trib.rb 就可以了建立集群了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis, 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装python</title>
      <link href="/2020/07/26/ubuntu-an-zhuang-python/"/>
      <url>/2020/07/26/ubuntu-an-zhuang-python/</url>
      
        <content type="html"><![CDATA[<p>由于 ubuntu20.04 自带的 python 版本是3.8，太高了，所以再安装 python3.7。</p><p>首先，安装好编译环境。</p><pre><code>sudo apt-get install -y liblzma-devsudo apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-devsudo apt-get install zlib1g-devsudo apt install libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev -ysudo apt install build-essential -y</code></pre><p>在官网下载安装包，并解压。</p><pre><code>sudo wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgzsudo tar -xzvf Python-3.7.1.tgzcd Python-3.7.1</code></pre><p>指定安装路径并编译安装，由于这里我安装在了 <code>/opt/</code> 下，所以之后和 python 相关的操作都要加 <code>sudo</code> 。</p><pre><code>sudo ./configure --enable-optimizations --prefix=/opt/python37/ sudo makesudo make install</code></pre><p>重点来了，安装完之后，在终端输入 python 还是会运行系统自带的版本，我们需要添加软连接。而在这里网上的教程都是把原来的指向 python3.8 的软连接 python3 清除，再新建软连接，经实测，这样做会导致后边引入包出现各种各样的错误。所以切记：<strong>一定不要动原系统自带的任何东西，不要怕麻烦，python 和 pip 都要新建立软连接</strong>，我这里命名为 python37, pip37，之后畅通无阻，没有任何报错。</p><p>安装完 python 之后，最好去 pypi 下载最新版本的 setuptools 和 pip，再各自的安装包中编译安装，这种方法最为保险，不会报错，另外 pip 建立软连接的问题和上述相同。</p><p>python 的基本工具已经安装完成，最后再安装一个虚拟环境建立工具即可，用 virtualenv 用惯了，这里就介绍它了。</p><p>安装用 pip 安装就好：</p><pre><code>sudo pip37 install virtualenv</code></pre><p>检查是否安装成功：</p><pre><code>virtualenv --version</code></pre><p>建立给定 python 解释器的虚拟环境：</p><pre><code>cd my_projectvirtualenv -p /usr/bin/python37 my_project_env</code></pre><p>启动虚拟环境：</p><pre><code>source my_project_env/bin/activate</code></pre><p>停止当前虚拟环境：</p><pre><code>deactivate</code></pre><p>顺便以 python 为例，记录一下修改环境变量的方法。</p><ol><li><p>方法一：</p><pre><code> export PATH=/opt/python37/bin:$PATH echo $PATH  # 查看配置结果</code></pre><p> <strong>生效方法</strong>：立即生效</p><p> <strong>有效期限</strong>：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="2"><li><p>方法二：<br> 修改 .bashrc 文件:</p><pre><code> vim ~/.bashrc</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：（有以下两种）</p><p> (1) 关闭当前终端窗口，重新打开一个新终端窗口就能生效</p><p> (2) 输入“source ~/.bashrc”命令，立即生效</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="3"><li><p>方法三:<br> 通过修改 profile 文件:</p><pre><code> vim /etc/profile</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：系统重启</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：对所有用户</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python，环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库基本操作</title>
      <link href="/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/"/>
      <url>/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="redis下载安装"><a href="#redis下载安装" class="headerlink" title="redis下载安装"></a>redis下载安装</h2><p>依次执行以下命令：</p><pre><code>$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar -zxvf redis-3.2.8.tar.gz$ sudo mv ./redis-3.2.8 /usr/local/redis$ cd /usr/local/redis$ sudo make$ sudo make test$ sudo make install</code></pre><p>安装完之后，查看 <code>/usr/local/bin</code>，如果有如下即安装成功。</p><pre><code>-rwxr-xr-x 1 root root 3344600 7月  24 14:38 redis-benchmark  # redis性能测试工具-rwxr-xr-x 1 root root   35872 7月  24 14:38 redis-check-aof  # AOF文件修复工具-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-check-rdb  # RDB文件修复工具-rwxr-xr-x 1 root root 3564272 7月  24 14:38 redis-cli  # redis命令行客户端lrwxrwxrwx 1 root root      12 7月  24 14:38 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-server  # redis服务器</code></pre><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>安装完成之后，会在 redis 文件夹爱中产生一个 <code>redis.conf</code> 配置文件，把它移到 <code>/etc/redis/</code> 中,修改其中内容进行配置。</p><pre><code> $ sudo cp redis.conf /etc/redis</code></pre><p>配置文件中需要注意的如下（修改过后）：</p><pre><code>bind 127.0.0.1                             # 默认绑定ip  port 6379                                  # 默认端口daemonize yes                              # 是否为守护进程（默认为no）logfile &quot;/var/log/redis/redis-server.log&quot;  # 日志文件（需要新建）databases 16                               # 默认16个数据库，编号0-15dbfilename dump.rdb                        # 数据文件dir /var/lib/redis                         # 数据文件存储路径（需要新建）slaveof                                    # 主从配置</code></pre><h2 id="redis服务端和客户端的启动"><a href="#redis服务端和客户端的启动" class="headerlink" title="redis服务端和客户端的启动"></a>redis服务端和客户端的启动</h2><p>服务端命令为 <code>redis-server</code>,<code>redis-server --help</code> 可查看帮助文档。<br>启动与关闭服务器如下：</p><pre><code>$ sudo redis-server /etc/redis/redis.conf  # 指定加载的配置文件，启动服务器$ ps aux | grep redis                      # 查看进程pid$ sudo kill -9 pid                         # 杀死服务器，即关闭</code></pre><p>客户端命令为 <code>redis-cli</code>,<code>redis-cli --help</code> 可查看帮助文档。<br>直接输入 <code>redis-cli</code> 即可连接服务端，输入 <code>ping</code> 起到检查连接的作用。</p><pre><code>$ redis-cli127.0.0.1:6379&gt; pingPONG</code></pre><p>利用 <code>select</code> 命令切换制定数据库，如：</p><pre><code>select 5</code></pre><h1 id="redis数据操作"><a href="#redis数据操作" class="headerlink" title="redis数据操作"></a>redis数据操作</h1><p><a href="doc.redisfans.com">redis命令大全</a> 很多命令可以去查找</p><p>以下代码有公式形式，匹配例子。</p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>设置的健不存在则添加，存在则修改。</p><ul><li>设置键值<pre><code>  set key value  set name itcast</code></pre></li><li>设置键值及过期时间，以秒为单位<pre><code>  setex key seconds value  setex aa 3 aa</code></pre></li><li>设置多个键值<pre><code>  mset key1 value1 key2 value2 ...  mset a1 python a2 java a3 c</code></pre></li><li>追加值<pre><code>  append key value  append a1 haha</code></pre></li><li>根据键获取值，如果不存在则返回 <code>nil</code> <pre><code>  get key  get name</code></pre></li><li>获取多个键的值<pre><code>  mget key1 key2 ...  mget a1 a2 a3</code></pre><h2 id="键命令"><a href="#键命令" class="headerlink" title="键命令"></a>键命令</h2></li><li>查找键，参数支持正则表达式<pre><code>  keys pattern  keys *       # 查看所有键  keys ‘a*’    # 包含 a 的键</code></pre></li><li>判断键是否存在，存在返回1，否则返回0<pre><code>  exists key1  exists a1</code></pre></li><li>查看对应的值的类型<pre><code>  type key  type a1</code></pre></li><li>删除键及对应的值<pre><code>  del key1 key2 ...   del a2 a3</code></pre></li><li>设置过期时间，以秒为单位<pre><code>  expire key seconds  expire &#39;a1&#39; 3</code></pre></li><li>查看有效时间<pre><code>  ttl key  setex bb 10 bb  ttl bb</code></pre></li></ul><h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>hash 用于存储对象，对象的结构为属性，值。值的类型为string。</p><ul><li>设置单个属性<pre><code>  hset key field value  hset user name itheima  # 如果报错，则表示为数据库快照，可执行下面命令使数据持久化  config set stop-writes-on-bgsave-error no</code></pre></li><li>设置多个属性<pre><code>  set key field1 value1 field2 value2  set u2 name itcast age 11</code></pre></li><li>获取指定键（对象）所有的属性<pre><code>  hkeys key  hkeys u2</code></pre></li><li>获取一个属性的值<pre><code>  hget key field  hget u2 name</code></pre></li><li>获取多个属性的值<pre><code>  hmget key field1 field2  hmget u2 name age</code></pre></li><li>获取所有属性的值<pre><code>  hvals key  hvals u2</code></pre></li><li>删除整个hash键及值，使用  <code>del</code> 命令</li><li>删除属性，属性对应的值会被一起删除<pre><code>  hdel key field1 field2 ...  hdel u2 age</code></pre></li></ul><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p>列表的元素类型为 <code>string</code>，按照插入顺序排序。</p><ul><li>在左侧插入数据<pre><code>  lpush key value1 value2 ...  lpush a1 a b c</code></pre></li><li>在右侧插入数据<pre><code>  rpush key value1 value2 ...  rpush a1 0 1</code></pre></li><li>在指定元素的前或后插入新元素<pre><code>  linsert key before或after 现有元素 新元素  linsert a1 before b 3</code></pre></li><li>获取列表里制定范围内的元素<pre><code>  lrange key start stop  lrange a1 0 -1</code></pre></li><li>设置指定索引位置的元素值<pre><code>  lset key index value  lset a 1 z</code></pre></li><li>删除指定元素<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>irem key count value</code></pre></li></ul></li></ul><h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p>无序集合，元素为 string 类型， 唯一性，不重复。对于集合没有修改操作。</p><ul><li>添加元素<pre><code>  sadd key member1 member2 ...  sadd a3 zhangsan sili wangwu</code></pre></li><li>返回所有元素<pre><code>  smembers key  smember a3</code></pre></li><li>删除指定元素<pre><code>  srem key memebr1  srem a3 wangwu</code></pre></li></ul><h2 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h2><p>有序集合，元素为 string 类型， 唯一性，不重复。每个元素都会关联一个double类型的score，表示权重。通过权重将元素从小到大排序，和 set 一样没有修改操作。</p><ul><li>添加元素<pre><code>  zadd key score1 member1 score2 member2 ...  sadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</code></pre></li><li>返回指定范围内元素<pre><code>  zrange keyy start stop  zrange a4 0 -1</code></pre></li><li>返回 score 值在 min 和 max 之间的元素（闭区间）<pre><code>  zrangebyscore key min max  zrangebyscore a4 5 6</code></pre></li><li>查看某 member 的 score 值<pre><code>  zscore key member  zscore a4 zhangsan</code></pre></li><li>萨和年初指定元素<pre><code>  zrem key member1 member2 ...  zrem a4 zhangsan</code></pre></li><li>删除 score 值在 min 和 max 之间的元素（闭区间）<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>zremrangebyscore key min maxzremrangebyscore a4 5 6</code></pre></li></ul></li></ul><h1 id="redis与python的交互"><a href="#redis与python的交互" class="headerlink" title="redis与python的交互"></a>redis与python的交互</h1><p><a href="python.jobbole.com">redis.py参考文档</a></p><p>StrictRedis 对象方法能操作 string 类型</p><pre><code>sr = StrictRedis(host = &#39;localhost&#39;, port = 6379, db = 0)# 上述都为默认值，可简写sr = StrictRedis()</code></pre><p>根据不同的类型，拥有不同的实例方法可以调用，与前面的 redis 命令对应，方法的参数与命令的参数也一致。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10+Ubuntu20.04双系统搭建过程</title>
      <link href="/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/"/>
      <url>/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>鬼知道我这两天重启了多少次电脑，那个小洞都快被我插烂了。。。</p><hr><p>因为有需求要用Ubuntu系统，之前用虚拟机实在是太卡了，索性下定决心装上双系统，总共用了将近2天时间才搞定，下面记录一下装机过程。（要是放图就太多了，不放了，步骤很详细）</p><hr><h2 id="提前准备的东西："><a href="#提前准备的东西：" class="headerlink" title="提前准备的东西："></a>提前准备的东西：</h2><ol><li>注意在装双系统之前要有一个空的盘和一和空的U盘，装机的过程会使之格式化，所以有重要文件一定要备份好。</li><li>下载一个U盘引导盘制作工具 rufus 软件。</li><li>下载好想下载的系统安装包，可以去官网下载或者找阿里云也可，我下的是最新版的 ubuntu20.04，是iso镜像文件。</li></ol><hr><h2 id="一-修改BIOS"><a href="#一-修改BIOS" class="headerlink" title="一. 修改BIOS"></a>一. 修改BIOS</h2><p>首先要进入 BIOS，不同电脑进入的方式可能会不一样，开机时按 <code>F12</code> 或 <code>F2</code> 可能会进入，但是我试了很多按法都没进去，索性直接在关机时用针插入电脑侧边的小洞（有恢复图标），最好找长一点的，太短了会没有反应。打开 BIOS 之后要做的是允许引导写入，做法是进入 BIOS，然后进入 Security，将 Secure Boot 从 Enable 改称 Disable。最后按 <code>F10</code>，保存自动重启电脑。</p><h2 id="二-制作引导盘"><a href="#二-制作引导盘" class="headerlink" title="二. 制作引导盘"></a>二. 制作引导盘</h2><p>插上空的U盘，打开 rufus 软件，在设备处选择自己插的U盘，在引导类型选择处选择系统安装包，目标系统类型 BIOS 或 UEFI，然后就可以开始了，然后点击OK之后，引导盘就制做好了。</p><h2 id="三-利用引导盘装系统"><a href="#三-利用引导盘装系统" class="headerlink" title="三. 利用引导盘装系统"></a>三. 利用引导盘装系统</h2><p>在关机的情况下插上U盘，同样插那个小孔，这次选择启动菜单 boot menu，选择用U盘来启动，进入 Ubuntu 。然后就按引导的步骤来，选中文，地区正常安装等等，注意在选择安装类型的时候选其他选项。这样我们就会自己来进行分区了。我们能看到空闲是非常小的。如果能到达这一步了，说明没什么问题，这个时候重启电脑，进入 Win10，终于要把 ubuntu 装进电脑了，我这里是装进了空的E盘。</p><p>进入 Win10 之后，右击此电脑，选择管理，进入磁盘管理，能看到电脑有几个盘有哪些空间，右击想装的盘，我这里是E盘，删除磁盘，删除之后就会显示有好大的空间没有分配了。而这些空间就是我们要重新分配的。</p><p>重启进入 ubuntu，回到 ubuntu 分区那一步骤，我们能看到空闲空间变得很大。我们就要分配这些空间，每次分区都先点击空闲，再点击加号。由于只讲步骤，这里先不谈 linux 的分区，下面几个分区一定不要弄错。</p><ol><li>建立 swap 交换空间，取8G，设置为主分区和空间起始位置；</li><li>建立 EFI 系统分区，取300M，设置为逻辑分区和空间起始位置；</li><li>建立 /home 分区，取150G，设置为逻辑分区和空间起始位置；</li><li>建立 /usr 分区，取100G，设置为逻辑分区和空间起始位置；</li><li>建立 / 分区，取剩下所有，设置为逻辑分区和空间起始位置。</li></ol><p>安装启动引导器的设备选 /dev/sda4，接下来就可以继续安装，按提示重启电脑了。如果设备理想兼容的话，再次重启就能进入系统选择了。然而我遇到了ubuntu系统卡紫屏的问题。。。</p><h2 id="四-修改内核参数解决卡紫屏"><a href="#四-修改内核参数解决卡紫屏" class="headerlink" title="四. 修改内核参数解决卡紫屏"></a>四. 修改内核参数解决卡紫屏</h2><p>查资料是显卡驱动的问题，之前用的 NVIDIA 显卡驱动，和新系统不适配。</p><p>紫屏时只能按电源关机，再重启进入引导页面时，按 <code>e</code> 键进入 <code>grub</code> 页面，在其中找到开头是linux的一行，再最后加上 <code>nomodeset</code> 这样能暂时禁用所有显卡驱动，<code>F10</code> 保存退出，就能正常打开ubuntu系统了，别忘了系统要更新，输入以下命令即可：</p><pre><code> $ sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre><p>更新之后最好再重启一下电脑，这时还得加上 <code>nomodeset</code> 才能打开，打开后搜索 <code>drivers</code> 就能看到额外驱动标签页，打开之后就能看到有很多可选择的驱动，而默认的并不是 NVIDIA，所以我们改称 NVIDIA，这样就不用每次开机都要修改内核参数了。</p><h2 id="五-两个小问题"><a href="#五-两个小问题" class="headerlink" title="五. 两个小问题"></a>五. 两个小问题</h2><ol><li><p>刚装完之后会遇到每次开机直接进入windows的情况</p><p> 查资料得知，因为 Windows 现在是快速启动， Windows8以上的系统关机实际上不是以前的关机，而是休眠，因此下次开机实际上是从休眠中恢复，因此是直接进入 Windows 。因此把快速启动关掉就可以了。</p></li><li><p>打开 ubuntu 再进入 Win10，总会比正常时间差 8 个小时</p><p> 查资料得知，Windows 和 Ubuntu 的时间设置方式是不一样的，造成了这种错误。在 Ubuntu 中把计算机硬件时间改成系统显示的时间，即禁用Ubuntu的UTC：</p><pre><code> timedatectl set-local-rtc 1 --adjust-system-clock</code></pre><p> 然后再重启电脑进入 Windows 修改时间即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 双系统，Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
