<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>卡尔曼滤波笔记</title>
      <link href="/2020/08/13/qia-er-man-lu-bo-bi-ji/"/>
      <url>/2020/08/13/qia-er-man-lu-bo-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>首先讨论了关于<strong>测量的数学构造</strong>，得到一个递推式，在推导卡尔曼滤波公式时应用了相同原理。</p><p>然后分别讨论了，<strong>数据融合</strong>，<strong>协方差矩阵</strong>，<strong>状态空间表达</strong>。其中数据融合就是根据测量值和分布确定最优值，这也是卡尔曼滤波滤去噪声得到最优解的根本思想。</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/1.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/2.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/3.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/4.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/5.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/6.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式整理</title>
      <link href="/2020/08/12/css-yang-shi-zheng-li/"/>
      <url>/2020/08/12/css-yang-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>以下为常用总结，更精细的参考官方文档：<a href="https://www.w3school.com.cn/cssref/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/index.asp</a></p><h2 id="常用CSS文本样式"><a href="#常用CSS文本样式" class="headerlink" title="常用CSS文本样式"></a>常用CSS文本样式</h2><ul><li><code>color</code>设置文字颜色;</li><li><code>font-size</code>设置文字大小;</li><li><code>font-family</code>设置文字字体;</li><li><code>font-style</code>设置文字是否倾斜，<code>normal</code>，<code>italic</code>;</li><li><code>font-weight</code>设置文字是否加粗，<code>normal</code>，<code>bold</code>;</li><li><code>line-height</code>设置文字行高，相当于文字的上下同时加间距;</li><li><code>font</code>可以同时设置文字几个属性，顺序：<em>是否倾斜 是否加粗 字号/行高 字体</em>；</li><li><code>text-decoration</code>设置文字下划线，<code>none</code>去掉下划线;</li><li><code>text-indent</code>设置文字首行缩进，<code>text-indent: 24px;</code>;</li><li><code>text-align</code>设置文字水平对齐方式，<code>center</code>居中;</li></ul><h2 id="CSS颜色表示法"><a href="#CSS颜色表示法" class="headerlink" title="CSS颜色表示法"></a>CSS颜色表示法</h2><ul><li><strong>颜色名</strong>，如<code>red</code>；</li><li><strong>rgb表示</strong>，如<code>rgb(255,0,0)</code>；</li><li><strong>16进制表示</strong>，如<code>#ff0000</code>；</li></ul><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ul><li><strong>标签选择器</strong>：影响较大，建议用在层级选择器中；</li><li><strong>id选择器</strong>：id不能重复；</li><li><strong>类选择器</strong>：最常用；</li><li><strong>层级选择器</strong>：主要用于选择父元素下的子元素，由<strong>空格</strong>分隔；</li><li><strong>组选择器</strong>：多个选择器有同样格式，用组选择器，由<strong>逗号</strong>分隔；</li><li><strong>伪类及伪元素选择器</strong>：<pre><code>  .box1:hover{color:red;}  .box2:before{content:‘行首文字’;}  .box3:after{content:‘行尾文字’;}</code></pre></li></ul><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p><img src="https://www.runoob.com/images/box-model.gif" alt=""></p><p>把元素称为盒子，设置对应的样式为：<strong>宽度(width)，高度(height)，边框(border)，盒子的内容与边框的间距(padding)，盒子与盒子之间的间距(margin)。</strong></p><ol><li>设置宽高<ul><li><code>width: 200px;</code> <strong>此宽度是盒子内容的宽度，不是整体的宽度</strong></li><li><code>height: 200px;</code> <strong>此高度是盒子内容的宽度，不是整体的高度</strong></li></ul></li><li>设置边框<ul><li><code>border-top-color: red;</code></li><li><code>border-top-width: 10px;</code></li><li><code>border-top-solid: solid;</code> 常用的还有<code>dashed</code>，<code>dotted</code></li><li>简写：<code>border-top: 10px red solid;</code></li><li>设置其他边框同理，如果设置四个边框直接<code>border: 10px red solid;</code></li></ul></li><li>设置内间距<ul><li>可以分别设置，如<code>padding-top: 20px;</code></li><li>也可以一起设置，如<code>padding: 20px 40px 50px 30px</code>，为上右下左</li><li>跟 3 个值为，上，左右，下</li><li>根 2 个值为，上下，左右</li><li>根 1 个值为，上下左右</li></ul></li><li>设置外边距：基本设置方法同上，有一些技巧与需要注意的地方<ul><li>设置元素水平居中 <code>margin: (x) auto;</code></li><li>margin设置<strong>负值</strong>可以让元素位移及边框合并</li><li><strong>外边距合并</strong>是指，当两个<strong>垂直外边距</strong>相遇时，它们将形成一个外边距。合并后的外边距高度等于其中的较大者，解决方法如下：<ul><li>就利用这种特性，不修改</li><li>只设置一边的外边距，一般设置<code>margin-top</code></li><li>将元素<strong>浮动或定位</strong></li></ul></li><li><strong>margin-top塌陷</strong>是指，当两个盒子嵌套的时候，内部的盒子设置的<code>margin-top</code>会加到外边的盒子上，导致内部的盒子<code>margin-top</code>设置失败，解决方法如下：<ul><li>外部盒子设置一个边框</li><li>外部盒子设置<code>overflow hidden</code></li><li>使用伪元素类<pre><code>  .clearfir:before{      content: &quot;&quot;;      display: table;  }</code></pre></li></ul></li></ul></li></ol><h2 id="CSS元素溢出"><a href="#CSS元素溢出" class="headerlink" title="CSS元素溢出"></a>CSS元素溢出</h2><p>当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的方式，通过<code>overflow</code>属性设置：</p><ul><li><code>visible</code>默认值，内容不会被修剪，会呈现在元素框之外</li><li><code>hidden</code>内容会被修剪，且其余内容不可见，此属性还有清除浮动，清除margin-top塌陷的功能</li><li><code>scroll</code>内容会被修剪，但是浏览器会显示滚动条以便查看其余内容</li><li><code>auto</code>如果内容被修剪，则浏览器会显示滚动条以便查看其余内容</li><li><code>inherit</code>从父元素继承overflow的值</li></ul><h2 id="CSS元素种类"><a href="#CSS元素种类" class="headerlink" title="CSS元素种类"></a>CSS元素种类</h2><ul><li>块元素：如 <code>div, p, ul, li, h1~h6, dl, dt, dd</code>等都是块元素，特性：<ul><li>支持全部样式</li><li>如果没有设置宽度，<strong>默认宽度为父级的100%</strong></li><li><strong>盒子占据一行，即使设置了宽度</strong></li></ul></li><li>内联元素：如<code>a, span, em, b, strong, i</code>等都是行内元素，特性：<ul><li>支持部分样式，<strong>不支持宽高，margin上下，padding上下</strong></li><li><strong>宽高由内容决定</strong></li><li>盒子并在一行</li><li><strong>代码换行，盒子会产生间距</strong>，解决产生间隙的方法：<ul><li>去掉内联元素之间的换行</li><li>将内联元素的父级设置<code>font-size: 0;</code>，内联元素自身再设置<code>font-size</code></li></ul></li><li>子元素是内联元素，父元素可以通过<code>text-align</code>设置子元素水平对其方式，</li></ul></li><li>内联块元素:<code>input</code>和<code>img</code>元素的行为类似这种元素，但是他们也归类于内联元素，可以用<code>display</code>属性转化，特性：<ul><li>支持全部样式 </li><li>如果没有设置宽高，宽高由内容决定</li><li>盒子并在一行</li><li>代码换行，盒子会产生间距</li><li>子元素是内联块元素，父元素可以通过<code>text-align</code>设置子元素水平对其</li></ul></li></ul><p><strong>以上三种元素，都可相互转化，但是实际开发中块元素用的较多，所以经常把内联元素转化为块元素，少量转化为内联；需要使用内联元素时，直接使用内联元素，而不用块元素转化了。</strong></p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>浮动分为左右<code>float: left;</code> <code>float: right;</code>，特性：</p><ul><li>浮动的元素会向左或向右浮动，<strong>碰到父元素边界，或其他元素才停下来</strong></li><li>相邻浮动的<strong>块元素可以并在一行</strong>，超出父级宽度就换行</li><li>浮动让行内元素或块元素<strong>自动转化为行内块元素，且不会有行内块元素间隙问题</strong></li><li>浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成<strong>文字绕图</strong>的效果</li><li>浮动元素之间<strong>没有margin的合并</strong></li><li>父元素如果没有设置尺寸（一般是高度不设置），父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动</li><li>清除浮动方法：<ul><li>父级上增加属性<code>overflow: hidden;</code></li><li>在最后一个子元素的后面加上一个空的div，给他样式属性<code>clear: both;</code>（不推荐）</li><li>使用成熟的清除浮动样式类,<code>clearfix</code>:<pre><code>  .clearfix:after, .clearfix:before{ content: &quot;&quot;; display: table;}  .clearfix:after{ clear: both;}  .clearfix{zoom: 1;}</code></pre></li><li>清除浮动的使用方法：<pre><code>  .con2{... overflow: hidden;}  # 或者  &lt;div class=&quot;con2 clearfix&quot;&gt;</code></pre></li></ul></li></ul><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流，是指盒子按照html标签编写顺序依次从上到下，从左到右排列，块元素占一行，行内元素在一行之内从左到右排列，先写的先排列，后写的排在后面，每个盒子都占据自己的位置。</p><p>可以使用<code>position</code>属性来设置元素定位类型：</p><ul><li><code>inherit</code>继承父元素<code>position</code>值</li><li><code>relative</code>生成相对定位元素，元素所占据的<strong>文档流位置保留</strong>，元素本身相对自身原位置进行偏移 </li><li><code>absolute</code>生成绝对定位元素，元素脱离文档流，不占据文档流位置，可以理解为漂浮在文档流的上方，相对于上一个设置了定位的父级元素进行定位，如果找不到，则相对于<code>body</code>元素进行定位</li><li><code>fixed</code>生成固定定位元素，元素脱离文档流，不占据文档流位置，可以理解为漂浮在文档流的上方，相对于浏览器窗口进行定位</li><li><code>static</code>默认值，不定位，保持原样</li></ul><p><strong>绝对定位和固定定位</strong>的块元素和行内元素会<strong>自动转化为行内块元素</strong>。</p><p><strong>定位元素的偏移</strong>：用<code>left, right, top, bottom</code>设置偏移值。</p><p><strong>定位元素层级</strong>：定位元素是浮动于正常文档流之上的，可以用<code>z-index</code>设置层级。</p><pre><code>.box {    position: absolute;    left: 200px;    top: 100px;    z-index: 10;}</code></pre><h2 id="background属性"><a href="#background属性" class="headerlink" title="background属性"></a>background属性</h2><p>负责给盒子设置背景图片和背景颜色，是复合属性，分为：</p><ul><li><code>background-color</code>颜色</li><li><code>background-image</code>图片地址</li><li><code>background-repeat</code>背景图如何平铺</li><li><code>background-position</code>背景图片位置</li><li><code>background-attachment</code>设置背景图片是固定还是随页面滚动条滚动</li><li>简写，如：<code>background: #00FF00 url(bgimage.gif) no-repeat left center fixed</code></li></ul><h2 id="CSS权重"><a href="#CSS权重" class="headerlink" title="CSS权重"></a>CSS权重</h2><p>指样式的优先级，有两条或多条样式作用于同一个元素，权重高的样式起作用，权重相同的，采取<strong>就近原则</strong>。等级如下：</p><ul><li><code>!important</code>加在样式属性后，权重为 <strong>10000</strong></li><li>内联样式，如：<code>style=&quot;&quot;</code>，权重为 <strong>1000</strong></li><li>id选择器，如:<code>#content {}</code>，权重为 <strong>100</strong></li><li>类，伪类和属性选择器，如<code>content, hover</code>，权重为 <strong>10</strong></li><li>标签选择器和伪元素选择器，如<code>div, p, before</code>，权重为 <strong>1</strong></li><li>通用选择器(<em>)，自选择器(&gt;)，相邻选择器(+)，同胞选择器(~)，权重为 *</em>0**</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代控制理论知识梳理</title>
      <link href="/2020/08/11/xian-dai-kong-zhi-li-lun-zhi-shi-shu-li/"/>
      <url>/2020/08/11/xian-dai-kong-zhi-li-lun-zhi-shi-shu-li/</url>
      
        <content type="html"><![CDATA[<p>最近学习了现代控制理论，把笔记存下来。</p><h2 id="State-Space-Representation-状态空间表达"><a href="#State-Space-Representation-状态空间表达" class="headerlink" title="State-Space Representation 状态空间表达"></a>State-Space Representation 状态空间表达</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/1.jpg" alt=""></p><h2 id="Phase-Portrait-相图-相轨迹"><a href="#Phase-Portrait-相图-相轨迹" class="headerlink" title="Phase Portrait 相图 相轨迹"></a>Phase Portrait 相图 相轨迹</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/2.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/3.jpg" alt=""></p><h2 id="Controllability-可控性"><a href="#Controllability-可控性" class="headerlink" title="Controllability 可控性"></a>Controllability 可控性</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/4.jpg" alt=""></p><h2 id="Stability-稳定性"><a href="#Stability-稳定性" class="headerlink" title="Stability 稳定性"></a>Stability 稳定性</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/5.jpg" alt=""></p><h2 id="Linear-Controler-Design-线性控制器设计"><a href="#Linear-Controler-Design-线性控制器设计" class="headerlink" title="Linear Controler Design 线性控制器设计"></a>Linear Controler Design 线性控制器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/6.jpg" alt=""></p><h2 id="Linear-Quadratic-regulator-LQR控制器"><a href="#Linear-Quadratic-regulator-LQR控制器" class="headerlink" title="Linear Quadratic regulator LQR控制器"></a>Linear Quadratic regulator LQR控制器</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/7.jpg" alt=""></p><h2 id="Follow-a-Desired-Path-轨迹跟踪"><a href="#Follow-a-Desired-Path-轨迹跟踪" class="headerlink" title="Follow a Desired Path 轨迹跟踪"></a>Follow a Desired Path 轨迹跟踪</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/8.jpg" alt=""></p><h2 id="Linear-Observer-Design-状态观测器设计"><a href="#Linear-Observer-Design-状态观测器设计" class="headerlink" title="Linear Observer Design 状态观测器设计"></a>Linear Observer Design 状态观测器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/9.jpg" alt=""></p><h2 id="Oberservability-and-Seperation-Principle-可观测性和分离原理"><a href="#Oberservability-and-Seperation-Principle-可观测性和分离原理" class="headerlink" title="Oberservability and Seperation Principle 可观测性和分离原理"></a>Oberservability and Seperation Principle 可观测性和分离原理</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/10.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 现代控制理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django其他一些技术</title>
      <link href="/2020/08/05/django-qi-ta-yi-xie-ji-zhu/"/>
      <url>/2020/08/05/django-qi-ta-yi-xie-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>网页里使用的 css, js, images属于于静态文件。</p><ul><li>新建静态文件夹<code>static</code>。</li><li>配置静态文件所在的物理目录。<code>settings.py</code><ul><li><code>STATIC_URL</code>设置访问静态文件对应的url；</li><li><code>STATICFILES_DIRS</code>设置静态文件所在的物理目录</li></ul></li><li>动态生成静态文件路径<pre><code>  &lt;!DOCTYPE html&gt;  {% load staticfiles %}  # 加载静态文件  &lt;html lang=&quot;en&quot;&gt;      &lt;img src=&quot;{% static 'images/123.jpg' %}&quot;&gt;  # 动态拼接静态文件路径  &lt;/html&gt;</code></pre></li><li>加载目录：先去配置的statics目录找，没找到再去各个应用下的statics目录找。</li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件函数是django框架给我们预留的函数接口，让我们可以干预请求和应答的过程。</p><p>中间件函数会在每一个视图函数执行前执行，所以我们可以修改或定义中间件函数来达到某向目的，比如：禁止某个 ip 地址访问所有网页，这个功能是可以通过装饰器实现的，但是需要在每个视图函数前面都加上装饰，很麻烦，而用中间件函数则很方便。</p><pre><code>EXCLUDE_IPS = []def blocked_ips(view_finc):    def wrapper(request, *view_args, **view_kwargs):        user_ip = request.META[&#39;REMOTE_ADDR&#39;]        if user_ip in EXCLUDE_IPS:            return HttpResponse(&#39;&lt;h1&gt;Forbidden&lt;h1&gt;&#39;)        else:            return view_finc(request, *view_args, **view_kwargs)    return wrapper@blocked_ipsdef static_test(request):    print(settings.STATICFILES_FINDERS)    # &#39;django.contrib.staticfiles.finders.FileSystemFinder&#39;, \    # &#39;django.contrib.staticfiles.finders.AppDirectoriesFinder&#39;    return render(request, &#39;booktest/static_test.html&#39;)@blocked_ipsdef index(request):    return render(request, &#39;booktest/index.html&#39;)</code></pre><ul><li><p>获取浏览器端的 ip 地址<br>  使用 request 对象的 META 属性： <code>request.META[&#39;REMOTE_ADDR&#39;]</code></p></li><li><p>在应用中新建<code>middleware.py</code></p></li><li><p>定义中间件类，在类中定义中间件预留函数，包括：</p><ul><li><p><code>__init__</code>: 服务器响应<strong>第一个请求</strong>的时候调用；</p></li><li><p><code>process_request</code>: 是在产生 request 对象，进行 url 匹配之前调用；</p></li><li><p><code>process_view</code>: 是 url 匹配之后，处理视图函数之前；</p></li><li><p><code>process_response</code>: 视图函数调用之后，内同返回给浏览器之前；</p></li><li><p><code>process_exception</code>: 视图函数出现异常，会调用这个函数；</p><p>以上叙述即是<strong>正常工作流程</strong>：浏览器向django第一次发送请求，django产生一个request同时执行<code>__init__</code>，之后执行<code>process_request</code>，之后进行url匹配，之后执行<code>process_view</code>，之后调用视图函数，之后执行<code>process_response</code>，之后给出相应，在过程中若视图函数异常，执行<code>process_exception</code>。</p><p>如果注册的多个中间件类中包含<code>process_exception</code>时，调用的顺序根注册的<strong>顺序是相反的</strong>。</p><pre><code># middleware.pyclass BlockedIPSMiddleWare(object):  EXCLUDE_IPS = []  def process_view(self, request, view_func, *view_args, **veiw_kwargs):      user_ip = request.META[&#39;REMOTE_ADDR&#39;]      if user_ip in BlockedIPSMiddleWare.EXCLUDE_IPS:          return HttpResponse(&#39;&lt;h1&gt;Forbidden&lt;h1&gt;&#39;)class TestMiddleWare(object):  def __init__(self):      print(&#39;----init----&#39;)  def process_request(self, request):      print(&#39;----process_request----&#39;)  def process_view(self, request, view_func, *view_args, **view_kwargs):      print(&#39;----process_view----&#39;)  def process_response(self, request, response):      print(&#39;----process_reponse----&#39;)      return responseclass ExceptionTest1MiddleWare(object):  def process_exception(self, request, exception):      print(&#39;----process_exception1----&#39;)      print(exception)class ExceptionTest2MiddleWare(object):  def process_exception(self, request, exception):      print(&#39;----process_exception2----&#39;)</code></pre></li></ul></li><li><p>注册中间件类：结合前面所说的顺序问题，当视图函数发生异常时，先执行<code>ExceptionTest2MiddleWare</code>。</p><pre><code>  MIDDLEWARE_CLASSES = (      &#39;booktest.middleware.BlockedIPSMiddleWare&#39;,      &#39;booktest.middleware.TestMiddleWare&#39;,      &#39;booktest.middleware.ExceptionTest1MiddleWare&#39;,      &#39;booktest.middleware.ExceptionTest2MiddleWare&#39;,  )</code></pre></li><li><p>还有一点需要注意的是，如果在流程中的任意位置返回了<code>response</code>，则<strong>直接跳到整个流程的最后一步</strong>，执行<code>process_response</code>，之后给出相应，这也是为什么最开始的装饰器可以达到干预应答的效果的原因。</p></li></ul><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><pre><code># models.pyclass AreaInfo(models.Model):    asize = models.BooleanField(default=False)    atitle = models.CharField(verbose_name=&#39;标题&#39;, max_length=20)    aParent = models.ForeignKey(&#39;self&#39;, null=True, blank=True)    def __str__(self):        return self.atitle    def title(self):        return self.atitle    title.admin_order_field = &#39;atitle&#39;    title.short_description = &#39;地区名称&#39;    def parent(self):        if self.aParent is None:            return &#39;&#39;        return self.aParent.atitle    parent.short_description = &#39;父级地区名称&#39;</code></pre><pre><code># admin.pyfrom booktest.models import AreaInfoclass AreaStackedInline(admin.StackedInline):    model = AreaInfo  # 多类名字    extra = 2class AreaTabularInline(admin.TabularInline):    model = AreaInfo  # 多类名字    extra = 2class AreaInfoAdmin(admin.ModelAdmin):    list_per_page = 10    list_display = [&#39;id&#39;, &#39;atitle&#39;, &#39;title&#39;, &#39;parent&#39;]    actions_on_bottom = True    actions_on_top = False    list_filter = [&#39;atitle&#39;]    search_fields = [&#39;atitle&#39;]    # fields = [&#39;aParent&#39;, &#39;atitle&#39;]    fieldsets = (        (&#39;基本&#39;, {&#39;fields&#39;:[&#39;atitle&#39;]}),        (&#39;高级&#39;, {&#39;fields&#39;:[&#39;aParent&#39;]})    )    inlines =  [AreaStackedInline]    # inlines = [AreaTabularInline]admin.site.register(AreaInfo, AreaInfoAdmin)</code></pre><h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><ul><li><p>配置上传文件保存目录</p><ul><li>新建<code>media</code>文件夹</li><li><code>MEDIA_ROOT = os.path.join(BASE_DIR, &#39;static/media&#39;)</code></li></ul></li><li><p>后台管理页面上传图片</p><ul><li>设计模型类<pre><code>  class PicTest(models.Model):      goods_pic = models.ImageField(upload_to=&#39;booktest&#39;)</code></pre></li><li>迁移生成表格</li><li>注册模型类</li></ul></li><li><p>用户自定义页面上传图片</p><ul><li><p>定义用户上传图片的页面并显示，是一个自定义的表单</p><pre><code>  &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/upload_handle&quot;&gt;      {% csrf_token %}      &lt;input type=&quot;file&quot; name=&quot;pic&quot;&gt;&lt;br&gt;      &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;  &lt;/form&gt;</code></pre></li><li><p>定义接受上传文件的视图函数：request 对象有一个<strong>FILES属性</strong>，类似于字典，通过request.FILES可以获取上传文件的处理对象。当上传文件不大于2.5M，文件放在内存中，若大于2.5M，文件内容写入临时文件中。</p><pre><code>  def show_upload(request):      return render(request, &#39;booktest/upload_pic.html&#39;)  def upload_handle(request):      # 1. 获取上传文件的处理对象      pic = request.FILES[&#39;pic&#39;]      print(type(pic))      # print(pic.name)      # pic.chunks()      # 创建一个文件      save_path = &#39;%/booktest/%s&#39;%(settings.MEDIA_ROOT, pic.name)      with open(save_path, &#39;wb&#39;) as f:          # 获取上传文件的内容 并写到创建的文件中          for content in pic.chunks():              f.write(content)      # 在数据库中保存上传记录      PicTest.objects.create(goods_pic=&#39;booktest/%s&#39;%pic.name)      # 返回      return HttpResponse(&#39;ok&#39;)</code></pre></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数和装饰器</title>
      <link href="/2020/08/04/gao-jie-han-shu-he-zhuang-shi-qi/"/>
      <url>/2020/08/04/gao-jie-han-shu-he-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数一般分为3种：</p><ol><li>函数作为另一个函数的参数；</li><li>函数作为另一个函数的返回值；</li><li>函数嵌套。</li></ol><p>前两种都比较好理解，举例看第三种：</p><p>调用外部函数是不会直接调用内部函数的，除非在外部函数内内部函数外调用了内部函数，比如下面的<code>return inner</code>其实就是返回了内部函数，所以<code>outer()()</code>实际上执行的就是<code>inner</code>函数。</p><p>对于外部函数内定义的变量<code>x</code>，如果想在内部函数修改，需要关键字<code>nonlocal</code>，易知<code>outer()()</code>会输出<code>20, 11</code></p><pre><code>def outer():    x = 10    def inner():        nonlocal x        y = x + 1        x = 20        print(x,y)    return innerouter()()</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个比较抽象的概念，实际上上面的代码段就是一个闭包，有两个特征：</p><ol><li>外部函数的返回值是内部函数；</li><li>内部函数中操作了外部函数中的变量。</li></ol><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器的基本结构如下，如果想写一个装饰器的话，就先写出这样的结构：</p><pre><code>def cal_time(fn):    def inner():        pass@cal_timedef demo():    pass</code></pre><p>根据以下代码说明装饰器的机理：</p><ol><li>遇见<code>@cal_time</code>即执行<code>cal_time</code>函数，但是这里外部函数中只有内部函数，所以没什么效果；</li><li><code>def demo(n)</code>中的<code>demo</code>函数已经变成了<code>cal_time</code>的参数<code>fn</code>；</li><li><code>m = demo()</code>中的<code>demo</code>函数其实是执行的装饰器函数中的内部函数<code>inner</code>。</li></ol><p><strong>分析：</strong>综合123，我们可以发现，<code>def demo(n)</code>只定义的一个输入参数<code>n</code>，而<code>m = demo(100000000, &#39;good&#39;, y=&#39;hello&#39;)</code>则有这么多参数，是因为这里的<code>demo</code>其实已经是<code>inner(x, *args, **kwargs)</code>，<code>s = fn(x)</code>之所以有输入参数且可以有返回值，是因为<code>def demo(n)</code>定义了一个输入参数且有一个返回值<code>return x</code>。把这两个<strong>替换关系</strong>搞明白了，装饰器就清楚了。</p><pre><code>def cal_time(fn):    def inner(x, *args, **kwargs):        start = time.time()        s = fn(x)        end = time.time()        return s, end - start    return inner@cal_timedef demo(n):    x = 0    for i in range(1,n):        x += i    return xm = demo(100000000, &#39;good&#39;, y=&#39;hello&#39;)print(m)</code></pre><h2 id="装饰器的应用"><a href="#装饰器的应用" class="headerlink" title="装饰器的应用"></a>装饰器的应用</h2><p>上面我们已经看到了，利用装饰器，可以非常方便地求出一个函数的运行时间，在这个函数的上面加上<code>@cal_time</code>然后再执行这个函数即可。</p><p>装饰器还强大在，当想添加需求或有新的输入参数时，可以完全不改动原函数，下面看一个例子，<code>play_game</code>是一个函数表示某人在玩某个游戏。现在想添加功能，超过22点就禁止玩游戏</p><pre><code>def play_game(name, game):    print(&#39;{} is playing {}&#39;.format(name, game))</code></pre><p>首先写出一个装饰器结构，这里的<code>fn</code>代表原来的<code>play_game</code>，而原函数有两个输入参数，所以<code>inner</code>中先传入两个参数<code>x,y</code>，根据新加的功能，至少还要输入时间点，所以再写入<code>*args, **kargs</code>：</p><pre><code>def can_play(fn):    def inner(x, y, *args, **kargs):        pass    return inner</code></pre><p>然后就判断输入的时间点是否超过22点即可，若没超过，执行<code>fn()</code>，完整如下，这样就实现了不改动原来函数的情形下，完成了新需求，利用<code>get</code>方法还可以设定默认值，防止输入时没有输入<code>clock</code>参数，达到了不给时间点，默认不让玩游戏的功能。</p><p>完整代码如下：</p><pre><code>def can_play(fn);    def inner(x, y, args, **kargs):        # if args[0] &lt;= 22:        if kwargs.get(&#39;clock&#39;, 23) &lt;= 22:            fn(x, y)        else:            print(&#39;Too late&#39;)    return inner@can_playdef play_game(name, game):    print(&#39;{} is playing {}&#39;.format(name, game))# play_game(&#39;123&#39;, &#39;abc&#39;, 18)play_game(&#39;123&#39;, &#39;abc&#39;, clock=23)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python，装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的模板</title>
      <link href="/2020/08/03/django-de-mo-ban/"/>
      <url>/2020/08/03/django-de-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="模板的功能"><a href="#模板的功能" class="headerlink" title="模板的功能"></a>模板的功能</h2><p>产生 html，控制页面上展示的内容。模板文件不仅仅是一个 html 文件。 模板文件包含两部分内容：</p><p>（1）静态内容：css，js，html；</p><p>（2）动态内容：用于动态产生一些网页内容，通过<strong>模板语言（简称DTL）</strong>来产生。</p><h2 id="模板文件的使用"><a href="#模板文件的使用" class="headerlink" title="模板文件的使用"></a>模板文件的使用</h2><p>通常是在视图函数中使用模板产生 html 内同返回给客户端，以下几步可以通过<code>render(request, template_path, context={})</code>一句话实现：</p><p>（1）加载模板文件：获取模板文件内容，产生一个模板对象；<code>temp = loader.get_template(&#39;booktest/index.html&#39;)</code></p><p>（2）定义模板上下文：给模板文件传递数据；<code>context = RequestContext(request, {})</code></p><p>（3）模板渲染产生 html 页面内容：用传递的数据替换相应的变量，产生一个替换后的表中 html 内容：<code>res_html = temp.render(context)</code></p><p>（4）返回应答：<code>return HttpResponse(res_html)</code></p><h2 id="模板文件加载顺序"><a href="#模板文件加载顺序" class="headerlink" title="模板文件加载顺序"></a>模板文件加载顺序</h2><p>（1）首先去配置的模板目录下面去找模板文件；<br>（2）去 <code>INSTALLED_APPS</code>下面的每个应用去找模板文件，前提是必须有<code>templates</code>文件夹。</p><h2 id="模板语言——模板变量"><a href="#模板语言——模板变量" class="headerlink" title="模板语言——模板变量"></a>模板语言——模板变量</h2><p>模板变量名是由数字，字母下划线和点组成的，不能以下划线开头。</p><p>使用模板变量：<code></code></p><p>模板变量的解析顺序：</p><ul><li><p>如果是<code>book.btitle</code></p><ol><li>把 book 当成一个字典，把 btitle 当成键名，进行取值 book[‘btitle’]；</li><li>把 book 当成一个对象，把 btitle 当成属性，进行取值 book.btitle；</li><li>把 book 当成一个对象，把 btitle 当成方法，进行取值 book.btitle；</li></ol></li><li><p>如果是<code>book.0</code></p><ol><li>把 book 当成一个字典，把 0 当成键名，进行取值 book[‘0’]；</li><li>把 book 当成一个列表，把 0 当成方下标，进行取值 book[0];</li></ol></li><li><p>如果解析失败，则产生内容时用<strong>空字符串</strong>填充模板变量。</p></li></ul><p><strong>使用模板变量时，前面的可能是一个字典，是一个对象，也可能是一个列表。</strong></p><h2 id="模板标签和内置过滤器"><a href="#模板标签和内置过滤器" class="headerlink" title="模板标签和内置过滤器"></a>模板标签和内置过滤器</h2><ul><li><p>for 循环：</p><pre><code>  {% for x in 列表 %}    # 列表不为空时执行    {% empty %}    # 列表为空时执行    {% endfor %}  # 可以通过 {{ forloop.counter }}得到循环遍历了几次</code></pre></li><li><p>条件判断</p><pre><code>  {% if 条件 %}    {% elif 条件 %}    {% else %}    {% endif %}</code></pre></li><li><p>关系比较操作符<code>&gt; &lt; &gt;= &lt;= == !=</code>，进行比较操作时，<strong>比较操作符两边必须由空格。</strong></p></li><li><p>逻辑运算： <code>not and or</code></p></li><li><p>过滤器：<strong>过滤器用于对模板变量进行操作</strong></p><p>  <strong>date</strong>: 改变日期的显示格式；</p><p>  <strong>length</strong>: 求长度。字符串，列表长度；</p><p>  <strong>default</strong>: 设置模板变量的默认值。</p><p>  格式：<strong>模板变量 | 过滤器： 参数</strong></p><p>  还有<strong>自定义过滤器</strong>，<strong>至少有一个参数，最多有两个参数</strong>。</p><pre><code>  # booktest/tamplatetags/filter.py  # 自定义过滤器  from django.template import Library  register = Library()  @register.filter  def mod(num):      return num%2  @register.filter  def mod_val(num, val):      return num%val ==0  # xxx.html  {% load filter %}  {{ book.btitle|length }}  {{ book.bupadte|date: 'Y年-m月-d日' }}  {% if book.id|mod %}  {% if book.id|mod_var:2 %}</code></pre><p>  具体的查参考文档：<a href="https://yiyibooks.cn/xx/django_182/index.html" target="_blank" rel="noopener">https://yiyibooks.cn/xx/django_182/index.html</a></p></li></ul><h2 id="模板语言——模板注释"><a href="#模板语言——模板注释" class="headerlink" title="模板语言——模板注释"></a>模板语言——模板注释</h2><ul><li>单行注释： ``</li><li>多行注释： <pre><code>  {% comment %}     注释内容     {% endcomment %}</code></pre></li></ul><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>很多网页都有相同的东西，比如导航条版权信息，可以创建一个父模板<code>base.html</code>，再建立很多子模板<code>child.html</code>来继承，只需要在子模板中写入一个语句，就会把父模板中所有内容拿来：</p><pre><code>{% extends 'booktest/base.html' %}</code></pre><p>注意在继承之后，再在子模板中写入各种东西是不会生效的。而子模板与父模板不同的地方，需要在父模板中预留位置，称为<strong>预留块</strong>，这样子模板就可以重写父模板预留块中的内容。预留块的写法以及重写预留块的方法如下：</p><pre><code># base.html{% block 块名 %}    可以写内容，也可以不写{% endblock 块名 %}# child.html{% block 块名 %}    {{ block.super }} # 加上这句话，就会获取父模板中这个块的内容    重写内容{% endblock 块名 %}</code></pre><h2 id="html转义"><a href="#html转义" class="headerlink" title="html转义"></a>html转义</h2><p>在<strong>模板上下文</strong>中的html标记默认是会被转义的。</p><ul><li><code>&lt;</code> 转换为 <code>&amp;lt;</code></li><li><code>&gt;</code> 转换为 <code>&amp;gt;</code></li><li><code>&#39;</code> 转换为 <code>&amp;#39;</code></li><li><code>&quot;</code> 转换为 <code>&amp;quot;</code></li><li><code>&amp;</code> 转换为 <code>&amp;amp;</code></li></ul><p>要关闭模板上下文字符串的转义，可以使用<code></code>；也可以使用:</p><pre><code>{% autoscape off %}模板语言代码{% endautoscape off %}</code></pre><p><strong>模板硬编码中的字符串默认不会转义</strong>，若要转义，需手动。</p><h2 id="csrf攻击"><a href="#csrf攻击" class="headerlink" title="csrf攻击"></a>csrf攻击</h2><p>跨站请求，修改密码。。。csrf伪造有两个关键点：</p><ol><li>登陆正常网站后，你的浏览器保存了sessionid，且没有退出；</li><li>不小心访问了另外一个网站，并且点击了页面上的按钮。。。</li></ol><p>django防止csrf的方式：</p><ol><li>默认打开了<strong>csrf中间件</strong>；</li><li>表单 post 提交数据时要加上 <code>csrf_token</code>标签。<pre><code> &lt;form method=&quot;post&quot;&gt;     {% csrf_token %} &lt;form&gt;</code></pre></li></ol><p><strong>防御原理：</strong></p><ol><li>渲染模板文件时在页面上生成一个名叫 csrfmiddlewaretoken 的隐藏域；</li><li>服务器交给浏览器保存一个名字为 csrftoken 的 cookie 信息。</li><li>提交表单时，两个值都会发送给服务器，服务器进行比对，如果一样，则 csrf 验证通过，否则失败。</li></ol><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><p>当某一个url配置的地址发生变化时，页面上使用反向解析生成地址的位置不需要发生变化。</p><p><strong>根据url正则表达式的配置动态的生成url。</strong></p><ul><li>在项目的根路由中包含具体应用的urls时，<strong>指定namespace</strong>；<pre><code>  urlpatterns = [      url(r&#39;^admin/&#39;, include(admin.site.urls)),      url(r&#39;^&#39;, include(&#39;booktest.urls&#39;, namespace=&#39;booktest&#39;)),  ]</code></pre></li><li>在应用的urls中配置<strong>指定name</strong>；<pre><code>  urlpatterns = [      url(r&#39;^index2/$&#39;, views.index, name=&#39;index&#39;),      url(r&#39;^show_arg/(\d+)/(\d+)/$&#39;, views.show_arg, name=&#39;show_arg&#39;),      url(r&#39;^show_kwarg/(?P&lt;num1&gt;\d+)/(?P&lt;num2&gt;\d+)/$&#39;, views.show_kwarg, name=&#39;show_kwarg&#39;),  ]</code></pre></li><li>在模板文件中使用时，<strong>url标签</strong>；<pre><code>  # {% url 'namespace : name' %}  {% url 'booktest : index' %}  # {% url 'namespace : name' 参数 %}  {% url 'booktest : show_arg' 10 20 %}  # {% url 'namespace : name' 关键字参数 %}  {% url 'booktest : show_arg' num1=10 num2=20 %}</code></pre></li><li>在重定向时使用反向解析:<pre><code>  from django.core.urlresolvers import reverse  def test_reverse(request):      # url = reverse(&#39;booktest:index&#39;)      # return redirect(url)      # url = reverse(&#39;booktest:show_args&#39;, args=(1,2))      # return redirect(url)      url = reverse(&#39;booktest:show_kwargs&#39;, kwargs={&#39;num1&#39;:3, &#39;num2&#39;:4})      return redirect(url)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的视图</title>
      <link href="/2020/08/02/django-de-shi-tu/"/>
      <url>/2020/08/02/django-de-shi-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="视图的功能"><a href="#视图的功能" class="headerlink" title="视图的功能"></a>视图的功能</h2><p>接受请求，进行处理，与 M 和 T 进行交互，返回应答。</p><p>（1）返回 html 内容<code>HttpResponse</code>；</p><p>（2）重定向<code>redirect</code>。</p><h2 id="视图函数的使用"><a href="#视图函数的使用" class="headerlink" title="视图函数的使用"></a>视图函数的使用</h2><p>（1）定义视图函数：<code>request</code>参数必须有。是一个<code>HttpResponse</code>类型的对象。参数名可以变化，但不要更改。</p><p>（2）配置 url，具体见基本应用。</p><h2 id="错误视图"><a href="#错误视图" class="headerlink" title="错误视图"></a>错误视图</h2><p>（1）<strong>404</strong>：<strong>url没有配置或配置错误</strong>找不到页面，关闭调试模式之后，默认会显示一个标准的错误页面，如果要显示自定义页面，则需要在 templates 目录下面自定义一个 404.html 文件</p><p>（2）<strong>500</strong>：<strong>视图出错</strong>服务器端的错误。</p><h2 id="捕获-url-参数"><a href="#捕获-url-参数" class="headerlink" title="捕获 url 参数"></a>捕获 url 参数</h2><p>进行 url 匹配时，把所需要捕获的部分设置成一个<strong>正则表达式组</strong>，这样就会自动把匹配成功后相应组的内容作为参数传递给视图函数。</p><p>（1）<strong>位置参数</strong>：参数名可以随意指定。<code>url(r&#39;^showarg(\d+)&#39;, views.show_arg)</code></p><p>（2）<strong>关键字参数</strong>：在位置参数的基础上给正则表达式组命名即可。<code>url(r&#39;^showarg(?P&lt;num&gt;\d+)&#39;, views.show_arg)</code></p><p>注：？P&lt;组名&gt;，<strong>关键字参数，视图中参数名必须与正则表达式组名一致。</strong></p><h2 id="request-的常用参数"><a href="#request-的常用参数" class="headerlink" title="request 的常用参数"></a>request 的常用参数</h2><p>以下除非特别声明，否则都是只读的。</p><ul><li><code>path</code>: 一个字符串，表示请求的页面的完整路径，不包含域名和参数部分；</li><li><code>method</code>: 一个字符串，表示是 GET 还是 POST；<ul><li>在浏览器中<strong>给出地址</strong>发出请求采用 GET，如超链接；</li><li>在浏览器中<strong>提交表单</strong>发起请求，若表单设置为 POST，则为POST；</li></ul></li><li><code>GET</code>: <code>QueryDict</code>类型对象，类似于字典，包含 get 请求方式所有参数；</li><li><code>POST</code>: <code>QueryDict</code>类型对象，类似于字典，包含 post 请求方式所有参数；</li><li><code>FILES</code>: 一个类似于字典的对象，包含所有上传的文件；</li><li><code>COOKIES</code>: 一个标准的 Python 字典，包含所有的 cookie，键和值都为ie字符串；</li><li><code>session</code>: 一个既可读又可写的类似于字典的对象，表示当前的会话，只有当 django 启用会话的支持时才可用，详细内容后面叙述。</li></ul><p>注：<code>QueryDict</code>可以一个键对应多个值，get方法只会取这个键的最后一个值，getlist方法取出所有。</p><p>给一个提交表单发出请求的实例：</p><pre><code># views.pydef login(request):    return render(request, &#39;booktest/login.html&#39;)def login_check(request):    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# urls.pyurlpatterns = [    url(r&#39;^login$&#39;, views.login),    url(r&#39;^login_check$&#39;, views.login_check),]# login.html&lt;form method=&quot;post&quot; action=&quot;/login_check&quot;&gt;    USERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    PASSWORD&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;</code></pre><h2 id="状态保持——Cookie"><a href="#状态保持——Cookie" class="headerlink" title="状态保持——Cookie"></a>状态保持——Cookie</h2><p>http协议是无状态的，下一次去访问一个页面时并不知道上一次对这个页面作了什么。而使用Cookie就是类似达到一种保存的功能，本质上cookie是<strong>由服务器生成，存储在浏览器的一小段文本信息</strong>。</p><p>想像你去饭店点菜，点完之后就去网吧玩了，打算估摸菜好了再回来吃；而老板很笨，记不住你点了什么菜，所以老板决定给你发一个小票上面记录了你要吃的所有东西并要求回来时带着小票这样老板就知道你要吃的是什么了。</p><p>在这个过程中，老板在你点菜之后给你小票，就是浏览器像服务器发起请求之后，web服务器生成Cookie信息然后让浏览器保存Cookie信息，再带着小票来，就是浏览器再把cookie发送给服务器，这基本上就是cookie的过程。</p><p>cookie 的特点：</p><p>（1）以<strong>键值对</strong>方式进行存储；</p><p>（2）通过浏览器访问一个网站时，会将浏览器存储的和这个网站相关的<strong>所有cookie信息</strong>发送给该网站的服务器，即<code>request.COOKIES</code>；</p><p>（3）cookie是基于域名安全的；</p><p>（4）cookie是有过期时间的，如果不指定，默认关闭浏览器之后cookie就会过期；</p><p>（5）cookie 无论保存什么值，<strong>取出时都是字符串。</strong></p><p>cookie 的设置：需要一个<code>HttpResponse</code>类的对象，或者是它的子类，<code>HttpReponseRedirect</code>，<code>JsonResponse</code>。可以通过<code>max_age</code>和<code>expires</code>参数设置过期时间。</p><pre><code># views.pydef set_cookie(request):    response = HttpResponse(&#39;set cookie&#39;, max_age=14*24*3600)    # response = HttpResponse(&#39;set cookie&#39;, expires=datetime.now()+timedelta(days=14))    response.set_cookie(&#39;num&#39;, 1)    return responsedef get_cookie(request):    num = request.COOKIES[&#39;num&#39;]    return HttpResponse(num)# urls.pyurlpatterns = [    url(r&#39;^set_cookie$&#39;, views.set_cookie),    url(r&#39;^get_cookie$&#39;, views.get_cookie),]</code></pre><p>在上述登录例子基础上，利用Cookie可以方便地实现<strong>记住用户名</strong>这一功能，只需要在登陆成功后设置cookie，再次显示页面时拿出cookie，并在html页面上设置value值显示即可：</p><pre><code># views.pydef login(request):    if &#39;username&#39; in request.COOKIES:        username = request.COOKIES[&#39;username&#39;]    else:        username = &#39;&#39;    return render(request, &#39;booktest/login.html&#39;, {&#39;username&#39;:username})def login_check(request):    # request.POST    # request.GET    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    remember = request.POST.get(&#39;remember&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        response = redirect(&#39;/index&#39;)        if remember == &#39;on&#39;:            response.set_cookie(&#39;username&#39;, username, max_age=7*24*3600)        return response        # return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# login.htmlUSERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ username }}&quot;&gt;&lt;br&gt;</code></pre><h2 id="状态保持——Session"><a href="#状态保持——Session" class="headerlink" title="状态保持——Session"></a>状态保持——Session</h2><p>想象你去网吧办了一张会员卡，网管给了你一个卡号，然后把你的姓名身份证等信息存储到了网吧电脑的表格里。</p><p>在django中，网吧电脑的表格就是 django_session，这个表格类似于字典，每一个主键对应一些信息，给你的卡号即是主键 session_key，电脑里存下的信息就是 session_data，而网馆给了你一个卡号，其实是服务器给浏览器设置了一个 cookie，这个 cookie 名叫<code>sessionid</code>，是读取session信息的惟一标识码，等再次访问网站时，浏览器获取 sessionid，并根据 sessionid 的值取出对应的 session 信息。而这些信息都在<code>request.session</code>属性中。 </p><p>session 的特点：</p><p>（1）session 是以<strong>键值对</strong>进行存储的，session_data可以在 mysql 数据库中的 django_session 表格中看到，其中 session_data 是经过 base64 编码之后的，解码之后就能看到，设置的键值对；</p><p>（2）session 依赖于 cookie，因为 sessionid 是 cookie；</p><p>（3）也有过期时间，不指定的话，默认两周过期。</p><p>（4）不像 cookie， session <strong>保存进去什么类型，取出就是什么类型.</strong></p><p>（5）session涉及到安全性要求比较高的数据，银行卡密码，账户等。相对而言，cookie安全性要求不高，可以记住用户名。</p><ul><li>session 的设置：<code>request.session[&#39;key&#39;] = value</code></li><li>根据键读取：<code>request.session.get(&#39;key&#39;, default)</code></li><li>清除所有session，在存储中删除值部分：<code>request.session.clear()</code></li><li>清除所有session，在存储中删除session整条数据：<code>request.session.flush()</code></li><li>删除session中指定键和值：<code>del request.session[&#39;key&#39;]</code></li><li>设置会话过期时间：<code>request.session.set_expiry(value)</code><ul><li>value是整数，将在value秒没有活动后过期；</li><li>value是0，将在浏览器关闭时过期；</li><li>value是None，将在两周后过期。</li></ul></li></ul><p>在上述登录例子基础上，利用session可以方便地实现<strong>记住登陆状态</strong>这一功能，只需要在登陆成功后设置session的一个键<code>islogin</code>，再次发出登陆情请求时，如果session表格里由<code>islogin</code>这个键，直接显示登陆成功的页面：</p><pre><code># def login_checkif username == &#39;smart&#39; and password ==&#39;123&#39;:    request.session[&#39;islogin&#39;] = True        return response# def loginif request.session.has_key[&#39;islogin&#39;]:    return redirect(&#39;/index&#39;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> django， Cookie， Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的模型</title>
      <link href="/2020/08/02/django-de-mo-xing/"/>
      <url>/2020/08/02/django-de-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="字段属性和选项："><a href="#字段属性和选项：" class="headerlink" title="字段属性和选项："></a>字段属性和选项：</h2><p>列举部分常用的，其余参考官方文档。</p><p>字段类型，使用时需要引入 django.db.models：</p><ul><li><code>Autofield</code>: 自增的，不用指定；</li><li><code>BooleanField</code>: 布尔；</li><li><code>NullBooleanField</code>: 支持 Null 的布尔；</li><li><code>CharField(max_length=)</code>: 字符串；</li><li><code>TextField</code>: 大文本字段，超过4000字；</li><li><code>IntegerField</code>: 整数；</li><li><code>DecimalFIeld(max_digits=None,decimal_places=None)</code>: 十进制浮点数；</li><li><code>FloatField</code>：浮点数，参数同上，没有 Deciaml 精确；</li><li><code>DateField([auto_now=False, auto_now_add=False])</code>: 日期，auto_now 会自动更新最后一次修改数据时间，auto_now_add 会自动添加创建数据时的时间，不可同时使用；</li><li><code>TimeField</code>: 时间，参数同上；</li><li><code>DateTimeField</code>: 日期时间，参数同上；</li><li><code>FileField</code>: 上传文字字段；</li><li><code>ImageField</code>: 继承于 FileField，对上传内容进行校验，确保是有效的图片。</li></ul><p>选项：</p><ul><li><code>default</code>: 设置默认值；</li><li><code>primary_key</code>: 设为主键，默认 False；</li><li><code>unique</code>: 字段在表中必须有唯一值，默认 False；</li><li><code>db_index</code>: 在表中会为此字段创建索引，默认 False；</li><li><code>db_column</code>: 字段名称，如未指定，则使用属性名称；</li><li><code>null</code>: 允许为空，默认 False；</li><li><code>blank</code>: 允许为空白，默认 False；</li></ul><p>注： null是数据库范畴的概念，blank 是后台管理页面表单验证范畴的。</p><p>当修改模型类之后，如果添加的选项不影响表的结构，则不需要重新迁移，default 和 blank 不影响表的结构。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><strong>查询函数：</strong></p><p>通过模型类<code>.objects</code>属性可以调用如下函数，实现对模型类对应的数据表的查询。</p><ul><li><p><code>get</code>: 返回一个模型类对象，参数写查询条件，查不到或者查到多条都会报错；</p></li><li><p><code>all</code>: 返回<code>QuerySet</code>类型； </p></li><li><p><code>filter</code>: 返回<code>QuerySet</code>类型，参数写查询条件； </p></li><li><p><code>exclude</code>: 同上；</p></li><li><p><code>order_by</code>: 返回<code>QuerySet</code>类型，参数写属性，默认从小到大排序，在属性前加‘-’为从大到小；</p><p>  <code>BookInfo.objects.order_by(&#39;-id&#39;)</code></p></li></ul><p><strong>查询条件：</strong></p><p>条件格式：模式类属性名__<strong>条件名</strong>=值</p><ul><li><p>判等 条件名：exact（可省略）<code>BookInfo.objects.get(id__exact=1)</code></p></li><li><p>模糊查询 条件名：contains（包含）endswith（结尾）startswith（开头）<code>BookInfo.objects.filter(btitle__contains=&#39;三&#39;)</code></p></li><li><p>空查询 条件名：isnull <code>BookInfo.objects.filter(id__isnull=False)</code></p></li><li><p>范围查询 条件名：in <code>BookInfo.objects.filter(id__in=[1,3,5])</code></p></li><li><p>比较查询 条件名：gt，lt，gte，lte </p><p>  id大于等于3：<code>BookInfo.objects.filter(id__gte=3)</code></p></li><li><p>日期查询</p><p>  1999年出版：<code>BookInfo.objects.filter(bupdate__year=1999)</code><br>  1980.1.1后出版：<code>BookInfo.objects.filter(bupdate__gt=date(1980,1,1))</code></p></li></ul><h2 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h2><p>作用：用于查询时条件之间的<strong>逻辑关系</strong>。not and or，可用Q对象进行&amp;|～操作。若不使用Q对象，默认写多个条件是且关系。</p><pre><code>from django.db.models import QBookInfo.objects.filter(id__gt=3，bread__gt=30)BookInfo.objects.filter(Q(id__gt=3)|Q(bread__gt=30))BookInfo.objects.filter(～Q(id=3))</code></pre><h2 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h2><p>作用：用于类属性之间的比较。</p><pre><code>from django.db.models import FBookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;))BookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;)*2)</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>作用：对查询结果进行聚合操作。sum count avg max min。调用 aggregate 来聚合，返回一个字典。</p><pre><code>from django.db.models import Sum, Count, Avg, Max, MinBookInfo.objects.all().aggregate(Count(&#39;id&#39;))# {&#39;id__count&#39;: 5}BookInfo.objects.all().aggregate(Sum(&#39;bread&#39;))# {&#39;bread__sum&#39;: 126}</code></pre><p><strong>count</strong>函数返回值是一个数字，也可以统计满足条件数据的数目。</p><pre><code>BookInfo.objects.all().count()BookInfo.objects.count()</code></pre><h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>对一个QuerySet对象，以上函数都可以继续使用。</p><p><strong>查询集特性：</strong></p><ul><li><strong>惰性查询：</strong>只有在实际使用查询集中的数据时才会发生对数据库的真正查询。</li><li><strong>缓存：</strong>当使用的是同一个查询集时，第一次的时候会发生实际数据库的查询。然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。</li></ul><p><strong>限制查询集：</strong><br>可以对一个查询集进行取下标或者切片来限制查询集的结果。</p><p>对一个查询集进行切片会产生<strong>新查询集</strong>，下标<strong>不允许为负数</strong>。</p><p>取出查询集第一条数据：</p><ul><li><code>b[0]</code> 若不存在，报 <code>IndexError</code></li><li><code>b[0:1]</code>.get() 若不存在，报 <code>DoesNotExist</code></li></ul><p>查询集的<strong>exists</strong>方法可以判断是否有数据。</p><h2 id="模型类关系"><a href="#模型类关系" class="headerlink" title="模型类关系"></a>模型类关系</h2><ul><li>多对多：<code>models.ManyToManyField()</code>，定义在哪都行；</li><li>一对一：<code>models.OneToOneField()</code>，定义在哪都行；</li><li>一对多：<code>models.ForeignKey()</code>，定义在多类中。</li></ul><p><strong>一对多的关联查询</strong></p><ul><li>用实例查询：<ul><li>由多查一：<code>h.hbook</code></li><li>由多查一的对象的id：<code>h.hbook_id</code></li><li>由一查多：<code>book.heroinfo_set.all()</code></li></ul></li><li>用模型类实现关联查询<ul><li>通过多类的条件查询一类的数据：<pre><code>  # 一类名.objects.filter(多类名小写__多类名属性__条件名)  BookInfo.objects.filter(heroinfo__hcomment__contains=&#39;丁&#39;)</code></pre></li><li>通过一类的条件查询多类的数据：<pre><code>  # 多类名.objects.filter(关联属性__一类名属性__条件名)  HeroInfo.objects.afilter(hbook__btitle=&#39;三体&#39;)</code></pre></li></ul></li></ul><h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><p>外键指向自身的属性，在查询时仍然按照一对多的关系查询。</p><pre><code># models.pyclass AreaInfo(model.Models):    atitle = model.CharFields(max_length=20)    aParent = models.Foreign(&#39;self&#39;, null=True, blank=True)# views.pydef areas(request):    area = AreaInfo.objects.get(atitle=&#39;广州&#39;)    parent = area.aParent    children = area.areainfo_set.all()</code></pre><h2 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h2><p>我们在查询中一直使用的 objects 其实是 django 自动生成的管理器 models.Manager() 类对象，我们也可以自定义，但是自定义管理器之后，django 便不会再自己生成 objects 管理器。</p><p>自定义分为两步：</p><p>（1）自定义一个管理器类，继承于 models.Manager()</p><p>（2）在具体的模型类中定义一个管理器类的对象。</p><p>自定义管理器类的应用场景：</p><p>（1）改变查询的结果集，比如调用 all 返回的是没有删除的图书的数据。</p><pre><code>class BookInfoManager(models.Manager):    def all(self):        books = super().all()        books = books.filter(isDelete=False)        return booksclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><p>（2）添加额外的方法使我们操作模型类对应的数据表。使用 self.model() 就可以创建一个根自定义管理器对应的模型类对象，这样作可以防止因为改换模型类的名字而相应也要改换管理器中的名字，避免了麻烦。</p><pre><code>class BookInfoManager(models.Manager):    def create_book(self, btitle, bupdate):        model_class = self.model        book = model_class()        book.btitle = btitle        book.bupdate = bupdate        book.save()        return bookclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><h2 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h2><p>django 默认生成的表名：<strong>应用名小写__模型类名小写</strong></p><p>元选项：需要在模型类中定义一个元类<code>Meta</code>，在里买年定义一个类属性 <code>db_table</code>就可以指定表名</p><pre><code>class BookInfo(model.Models):    class Meta:        db_table = &#39;new_sheet_name&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的基本应用</title>
      <link href="/2020/07/30/django-de-ji-ben-ying-yong/"/>
      <url>/2020/07/30/django-de-ji-ben-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="项目与应用创建"><a href="#项目与应用创建" class="headerlink" title="项目与应用创建"></a>项目与应用创建</h2><pre><code>django-admin startproject test1  # 创建 test1 项目python37 manage.py startapp booktest  # 创建 booktest 应用</code></pre><ul><li>项目目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>settings.py</code> 项目的配置文件；</li><li><code>urls.py</code> 进行 url 路由的配置；</li><li><code>wsgi.py</code> web 服务器和 Django 交互的入口</li><li><code>manage.py</code> 项目的管理文件。</li></ol></li><li>应用目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>model.py</code> 写和数据库相关的功能；</li><li><code>views.py</code> 接受请求，进行处理，与 M 和 T 进行交互，返回应答，定义处理函数，称为视图函数；</li><li><code>test.py</code> 写测试代码的文件；</li><li><code>admin.py</code> 网站后台管理相关的文件</li></ol></li></ul><p>还需要建立应用与项目之间的联系，需要对应用进行注册。<br>修改<code>settings.py</code>中的 INSTALLED_APPS 配置项，加入自己的应用名称即可。</p><pre><code>INSTALLED_APPS = (    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;booktest&#39;,  # 注册应用)</code></pre><h2 id="配置-mysql-数据库"><a href="#配置-mysql-数据库" class="headerlink" title="配置 mysql 数据库"></a>配置 mysql 数据库</h2><p>Django 自带的数据库是 sqlite 相对小型，在大项目中用的更多的是 oracle 和 mysql，所以要替换。</p><p>模型是对数据库的相关操作，利用 Django 配置 mysql 数据库，需要修改<code>settings.py</code>中的 DATABASE。</p><pre><code>DATABASES = {    &#39;default&#39;: {        # &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,          # &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),        &#39;NAME&#39;: &#39;qay&#39;,            # 数据库名称        &#39;USER&#39;: &#39;root&#39;,           # 登陆数据库的用户名        &#39;PASSWORD&#39;: &#39;qin200053&#39;,  # 登陆密码        &#39;HOST&#39;: &#39;localhost&#39;,      # 登陆地址        &#39;PORT&#39;: &#39;3306&#39;,           # 端口号，mysql默认端口号是3306    }}</code></pre><p>注意：django不会生成数据库，需要我们自己创建。</p><p>我的 Ubuntu 版本是20.04，mysql官网上只有8.0才支持20.04，于是我直接安装的 mariadb 暂时作为 mysql 的替代品，目前看来命令没什么区别，希望以后不会出什么bug。</p><pre><code>sudo apt-get mariadb-server mariadb-client  # 安装</code></pre><ul><li>开启关闭服务，登陆退出。<pre><code>  sercive mysql start  service mysql stop  sudo mysql -uroot </code></pre></li><li>避免使用 sudo 登陆,需要执行<code>sudo vim /etc/mysql/my.cnf</code>，然后添加如下语句，再重启服务即可。<pre><code>  [mysqld]  skip-grant-tables</code></pre></li><li>修改mysql密码。<pre><code>  mysql -uroot -p  use mysql   update user set authentication_string=password(&#39;xxxxxx&#39;) where User=&#39;root&#39;;</code></pre></li><li>创建新的数据库<pre><code>  mysql -uroot -p  show databases;  create database qay charset=utf8;  show databases; </code></pre></li></ul><p>处理完 mysql，在启动项目之前，需要<code>sudo pip37 install pymysql</code>，并在项目的<code>__init__.py</code>中加入如下语句，就可以了。</p><pre><code>import pymysqlpymysql.install_as_MySQLdb()</code></pre><h2 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h2><p>我们需要设计和数据库中表相对应的类，称为模型类，本质上就是在<code>models.py</code>中建立 class，其必须继承于 models.Model类。</p><pre><code>class BookInfo(models.Model):    &#39;&#39;&#39;图书模型类&#39;&#39;&#39;    # 图书名称，字符串，最长20    btitle = models.CharField(max_length=20)    # 出版日期，日期类型    bupdate = models.DateField()</code></pre><p>设计完模型类之后，将其生成为数据库中的表：</p><ul><li><p>生成迁移文件<code>python37 manage.py makemigrations</code>，文件生成在 migrations 文件夹中；</p></li><li><p>执行迁移生成表<code>python37 manage.py migrate</code>，这样去数据库里就能查看到了，创建的表名即为<code>应用名_类名</code>。</p></li><li><p>接下来就可以通过python语句，对数据进行操作了，利用 <code>python37 manage.py shell</code>进行操作：</p><pre><code>  &gt;&gt;&gt; from booktest.models import BookInfo  &gt;&gt;&gt; b = BookInfo()  &gt;&gt;&gt; b.btitle = &#39;三体&#39;  &gt;&gt;&gt; from datetime import date  &gt;&gt;&gt; b.bupdate = date(1990,1,1)  &gt;&gt;&gt; b.save()  # 通过 save 进行插入和修改  &gt;&gt;&gt; b_all = BookInfo.objects.all()   # 拿到所有实例，即表中所有条目，返回一个列表  &gt;&gt;&gt; b2 = BookInfo.objects.get(id=1)  # 拿到实例，可以借此查询  &gt;&gt;&gt; b_cond = BookInfo.objects.get(btitle=&#39;三体&#39;)  # 按条件查询  &gt;&gt;&gt; type(b2)  &lt;class &#39;booktest.models.BookInfo&#39;&gt;  &gt;&gt;&gt; b2.btitle  &#39;三体&#39;  &gt;&gt;&gt; b2.bupdate  datetime.date(1990,1,1)  &gt;&gt;&gt; b2.delete()  # 通过 delete 删除</code></pre></li></ul><pre><code>class HeroInfo(models.Model):    hname = models.CharField(max_length=20)    hgender = models.BooleanField(default=False)    hcomment = models.CharField(max_length=128)    # 关系属性 hbook，建立图书类和英雄人物类之间的一对多关系    hbook = models.ForeignKey(&#39;BookInfo&#39;)</code></pre><p>表之间存在关系。</p><ul><li><p>Models.ForeignKey 可以建立两个模型之间一对多的关系，django 在生成表的时候，就会在多的表中创建一列作为外键，建立两个表之间一对多的关系。关系属性对应的表的字段名格式为<code>关系属性名_id</code>。</p><p>  以上面的类作为例子，很多英雄可能都属于一本书，所以在‘多类’中添加关系属性，赋值时要赋‘一类’的实例，在实际的表中，<code>h</code>的属性<code>hbook_id</code>的值即为<code>b</code>的主键<code>id</code>值：</p><pre><code>  b = BookInfo()  h = HeroInfo()  h.hbook = b</code></pre></li><li><p>建立了关系之后，可以根据关系查询：</p><p>  由一查多：<code>b.heroinfo_set.all()</code><br>  由多查一：<code>h.hbook</code></p></li></ul><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><ul><li><p>修改<code>settings.py</code>，语言和时区本地化</p><pre><code>  LANGUAGE_CODE = &#39;zh_hans&#39;  TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre></li><li><p>创建管理员</p><pre><code>  python37 manage.py createsuperuser</code></pre></li><li><p>在<code>admin.py</code>中注册模型类</p><pre><code>  admin.site.register(BookInfo)  admin.site.register(HeroInfo)</code></pre></li><li><p>启动项目后在浏览器输入<code>http://127.0.0.1:8000/admnin</code></p></li><li><p>自定义管理页面，在 admin 中建立自定义管理类</p><pre><code>  class BookInfoAdmin(admin.ModelAdmin):      list_display = [&#39;id&#39;,&#39;btitle&#39;,&#39;bupdate&#39;]  admin.site.register(BookInfo, BookInfoAdmin)</code></pre></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在 Django 中，通过浏览器去请求一个页面时，使用视图函数来处理这个请求，视图函数处理之后，要给浏览器返回页面内容。</p><ul><li><p>在<code>views.py</code>中定义视图函数</p><p>  视图函数必须有一个参数<code>request</code>，处理之后需要返回一个 HttpResponse 的类对象。</p><pre><code>  # http://127.0.0.1:8000/index  def index(request):      return HttpResponse(&quot;nb!&quot;)</code></pre></li><li><p>配置项目路由</p><pre><code>  urlpatterns = [      url(r&#39;^admin/&#39;, include(admin.site.urls)),      url(r&#39;^&#39;, include(&#39;booktest.urls&#39;)),  ]</code></pre></li><li><p>配置应用路由，需要自己在应用目录下创建<code>urls.py</code></p><pre><code>  urlpatterns = [      url(r&#39;index$&#39;, views.index),  ]</code></pre></li><li><p>路由匹配过程</p><p>  当浏览器中输入<code>http://127.0.0.1:8000/index</code>，会自动除去前面的<code>http://127.0.0.1:8000/</code>用剩下的部分进行匹配，这里即<code>index</code>，先根据项目路由中的<code>urlpatterns</code>从上到下匹配，匹配成功后，根据后面的<code>include()</code>确定下一部去哪个应用进行匹配，这里即<code>booktest.urls</code>，然后再到<code>urlpatterns</code>从上到下匹配，直到匹配成功为止。</p><p>  匹配时严格根据正则规则匹配。（在新版本的django中函数 url 改成了函数 path，已经不需要正则表达式了）</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>创建模板文件夹<code>templates</code>,并在<code>settings.py</code>的 TEMPLATES 中配置模板目录，通常可能有很多应用，所以在<code>templates</code>再以应用名建立文件夹<code>booktest</code><pre><code>  &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],</code></pre></li><li>使用模板文件分为三步：<ol><li>加载模板文件：去模板目录下获取html文件内容，得到一个模板对象；</li><li>定义模板上下文：像模板文件传递数据，传递时以键值对形式传递；</li><li>模板渲染：得到一个标准的html内容。<pre><code>def my_render(request, template_path, context_dict): temp = loader.get_template(&#39;booktest/index.html&#39;) context = RequestContext(request, {})  # 这里传了空字典 res_html = temp.render(context) return HttpResponse(res_html)</code></pre></li><li>以上三步可以用一个函数<code>render</code>完成:<pre><code>def index(request): # 传了两个变量，一个字符串一个列表 return render(request, &#39;booktest/index.html&#39;,           {&#39;content&#39;:&#39;hello world&#39;,&#39;list&#39;:list(range(1,10))})  </code></pre></li></ol></li><li>模板文件不仅仅时一个html文件，可以说有自己的语法，变量需要用两组花括号包裹，循环遍历或判断要用花括号和百分号包裹，下面给出一个例子：<pre><code>  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;mplate file&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;h1&gt;this is a template file&lt;/h1&gt;      use the template variable: &lt;br&gt;      {{ content }} &lt;br&gt;      use the list: &lt;br&gt;      {{ list }} &lt;br&gt;      for loop: &lt;br&gt;      &lt;ul&gt;          {% for i in list %}                &lt;li&gt;{{ i }}&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre></li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在视图函数的返回中，可以返回给定的一个模板，也可以根据 url 返回到另一个网址，这种就叫做重定向，下面就是在页面上显示书籍之后，新增或删除书籍之后仍返回 index 页面的例子，其中redirect 就是 HttpResponseRedirect 的一个简写。</p><p>注意，在html中有重定向，写到了链接时，为避免出错字符串要以<code>/</code>开头。</p><pre><code>def create(request):    b = BookInfo()    b.btitle = &#39;乡村教师&#39;    b.bupdate = date(1999,9,9)    b.save()    # return HttpResponse(&#39;ok&#39;)    return HttpResponseRedirect(&#39;/indexx&#39;)def delete(request, bid):    b = BookInfo.objects.get(id=bid)    b.delete()    return redirect(&#39;/indexx&#39;)</code></pre><h2 id="很简单的一个实例"><a href="#很简单的一个实例" class="headerlink" title="很简单的一个实例"></a>很简单的一个实例</h2><p>做一个很简单的实例，输入<code>http://127.0.0.1:8000/books</code>进入页面显示书名，点击书名能跳转到书所包含的人物信息。</p><ul><li><p>最重要的就是设计视图函数</p><pre><code>  def show_books(request):      books = BookInfo.objects.all()      return render(request, &#39;booktest/show_books.html&#39;,                  {&#39;books&#39;:books})  def detail(request, bid):      book = BookInfo.objects.get(id=bid)      heros = book.heroinfo_set.all()      return render(request, &#39;booktest/detail.html&#39;,          {&#39;book&#39;:book, &#39;heros&#39;:heros})</code></pre></li><li><p>配置各个页面的路由</p><pre><code>  urlpatterns = [      url(r&#39;^books$&#39;, views.show_books),      url(r&#39;^books/(\d+)$&#39;, views.detail),  ]</code></pre></li><li><p>编写模板呈现页面</p><pre><code>      # show_books.html      Information of Book is Followed:      &lt;ul&gt;          {% for book in books %}            &lt;li&gt;&lt;a href="/books/{{ book.id }}"&gt;{{ book.btitle }}&lt;/a&gt;&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;      # detail.html      &lt;h1&gt;{{ book.btitle }}&lt;/h1&gt;      Information of Heros is Followed:&lt;br&gt;      &lt;ul&gt;          {% for hero in heros %}                &lt;li&gt;{{ hero.hname }}--{{ hero.hcomment }}&lt;/li&gt;            {% empty %}                &lt;li&gt;no Information of Hero&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  </code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从集群的部署</title>
      <link href="/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/"/>
      <url>/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>主从，直观来说就是备份，当一个 redis 服务挂掉时，为了防止数据丢失或者不能使用，有一个副本来代替原来的服务。</p><h3 id="配置主"><a href="#配置主" class="headerlink" title="配置主"></a>配置主</h3><ul><li>查看当前主机 ip 地址 <code>ifconfig</code></li><li>修改 redis.conf 中的 bind <code>bind 192.168.xx.xx</code></li><li>重启 redis 服务 <code>redis-server redis.conf</code></li></ul><h3 id="配置从"><a href="#配置从" class="headerlink" title="配置从"></a>配置从</h3><ul><li>复制 redis.conf <code>sudo cp redis.conf ./slave.conf</code></li><li>修改 slave.conf 文件 <code>sudo vim slave.conf</code></li><li>编辑如下内容，注意端口号不能和主重复<pre><code>  bind 192.168.xx.xx  slaveof 192.168.xx.xx 6379  # 这是额外添加的一项  port 6378</code></pre></li><li>启动从服务 <code>sudo redis-server save.conf</code></li><li>查看主从关系 <code>redis-cli -h 192.168.xx.xx info Replication</code></li></ul><h3 id="主从配置下数据操作"><a href="#主从配置下数据操作" class="headerlink" title="主从配置下数据操作"></a>主从配置下数据操作</h3><p>与正常基本没有区别。</p><p>在主和从分别执行 info 命令查看输出信息后，进入主客户端，写数据；这时进入从客户端就可以读数据了。</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>集群，直观来讲就是好多 redis 服务作为一个整体对外工作，人多力量大。</p><p>集群分为两种，一种是软件集群，即只有一台电脑上面开启了很多 redis 服务，将这些服务集群；另一种是硬件集群，即有很多电脑，每台电脑上都有一个或很多 redis 服务，将所有服务集群。</p><p>集群中的主节点负责处理槽（存储数据），从节点则是主节点的复制品；</p><p>Redis集群将整个数据库分成16384个槽，数据库中的每个键都属于16384个槽中的其中一个；</p><p>集群中的每个主节点都可以负责0到16384个槽，当16384个槽都有节点在负责时，集群进入上线状态，可以执行客户端发送的数据命令；</p><p>可以在 conf 文件中更改槽的总数。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>试验时，在本机上开启6个服务做集群。</p><ul><li>创建 conf 目录</li><li>在 conf 目录下创建 7000.conf，编辑内容如下：<pre><code>  port 7000  bind 192.168.xx.xx  daemonize yes  # 作为守护进程运行  pidfile 7000.pid  # 运行后进程 id 写入这里  cluster-enabled yes  # 可以作为集群的节点  cluster-config-file 7000_node.conf  # 集群节点的配置文件  cluster-node-timeout 15000  # 连接集群节点的超时时间  appendonly yes  # 数据文件可追加</code></pre></li><li>同理创建7001，7002，7003，7004，7005</li><li>开启6个服务</li><li>用 redis-trib.rb 命令就可以创建集群，命令在源码包的 src 下，可以通过 cp 复制到 /usr/local/bin<pre><code>  redis-trib.rb create --replicas 1 192.168.101.145:7000 192.168.101.145:7001 192.168.101.145:7002 192.168.101.145:7003 192.168.101.145:7004 192.168.101.145:7005</code></pre></li></ul><p>如果没有报错，则说明集群建立成功了。</p><p>如果报错了。说明 ruby 的最新版本，按照如下方法解决。</p><pre><code>$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB$ curl -sSL https://get.rvm.io | bash -s stable$ source ~/.bashrc$ source ~/.bash_profile$ rvm list known$ rvm install 2.7.1 --disable-binary$ rvm use 2.7.1 --default$ rvm list$ gem install redis  # 最后安装 redis 集群接口</code></pre><p>执行完以上代码之后，再执行 redis-trib.rb 就可以了建立集群了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis, 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装python</title>
      <link href="/2020/07/26/ubuntu-an-zhuang-python/"/>
      <url>/2020/07/26/ubuntu-an-zhuang-python/</url>
      
        <content type="html"><![CDATA[<p>由于 ubuntu20.04 自带的 python 版本是3.8，太高了，所以再安装 python3.7。</p><p>首先，安装好编译环境。</p><pre><code>sudo apt-get install -y liblzma-devsudo apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-devsudo apt-get install zlib1g-devsudo apt install libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev -ysudo apt install build-essential -y</code></pre><p>在官网下载安装包，并解压。</p><pre><code>sudo wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgzsudo tar -xzvf Python-3.7.1.tgzcd Python-3.7.1</code></pre><p>指定安装路径并编译安装，由于这里我安装在了 <code>/opt/</code> 下，所以之后和 python 相关的操作都要加 <code>sudo</code> 。</p><pre><code>sudo ./configure --enable-optimizations --prefix=/opt/python37/ sudo makesudo make install</code></pre><p>重点来了，安装完之后，在终端输入 python 还是会运行系统自带的版本，我们需要添加软连接。而在这里网上的教程都是把原来的指向 python3.8 的软连接 python3 清除，再新建软连接，经实测，这样做会导致后边引入包出现各种各样的错误。所以切记：<strong>一定不要动原系统自带的任何东西，不要怕麻烦，python 和 pip 都要新建立软连接</strong>，我这里命名为 python37, pip37，之后畅通无阻，没有任何报错。</p><p>安装完 python 之后，最好去 pypi 下载最新版本的 setuptools 和 pip，再各自的安装包中编译安装，这种方法最为保险，不会报错，另外 pip 建立软连接的问题和上述相同。</p><p>python 的基本工具已经安装完成，最后再安装一个虚拟环境建立工具即可，用 virtualenv 用惯了，这里就介绍它了。</p><p>安装用 pip 安装就好：</p><pre><code>sudo pip37 install virtualenv</code></pre><p>检查是否安装成功：</p><pre><code>virtualenv --version</code></pre><p>建立给定 python 解释器的虚拟环境：</p><pre><code>cd my_projectvirtualenv -p /usr/bin/python37 my_project_env</code></pre><p>启动虚拟环境：</p><pre><code>source my_project_env/bin/activate</code></pre><p>停止当前虚拟环境：</p><pre><code>deactivate</code></pre><p>顺便以 python 为例，记录一下修改环境变量的方法。</p><ol><li><p>方法一：</p><pre><code> export PATH=/opt/python37/bin:$PATH echo $PATH  # 查看配置结果</code></pre><p> <strong>生效方法</strong>：立即生效</p><p> <strong>有效期限</strong>：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="2"><li><p>方法二：<br> 修改 .bashrc 文件:</p><pre><code> vim ~/.bashrc</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：（有以下两种）</p><p> (1) 关闭当前终端窗口，重新打开一个新终端窗口就能生效</p><p> (2) 输入“source ~/.bashrc”命令，立即生效</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="3"><li><p>方法三:<br> 通过修改 profile 文件:</p><pre><code> vim /etc/profile</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：系统重启</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：对所有用户</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python，环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库基本操作</title>
      <link href="/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/"/>
      <url>/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="redis下载安装"><a href="#redis下载安装" class="headerlink" title="redis下载安装"></a>redis下载安装</h2><p>依次执行以下命令：</p><pre><code>$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar -zxvf redis-3.2.8.tar.gz$ sudo mv ./redis-3.2.8 /usr/local/redis$ cd /usr/local/redis$ sudo make$ sudo make test$ sudo make install</code></pre><p>安装完之后，查看 <code>/usr/local/bin</code>，如果有如下即安装成功。</p><pre><code>-rwxr-xr-x 1 root root 3344600 7月  24 14:38 redis-benchmark  # redis性能测试工具-rwxr-xr-x 1 root root   35872 7月  24 14:38 redis-check-aof  # AOF文件修复工具-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-check-rdb  # RDB文件修复工具-rwxr-xr-x 1 root root 3564272 7月  24 14:38 redis-cli  # redis命令行客户端lrwxrwxrwx 1 root root      12 7月  24 14:38 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-server  # redis服务器</code></pre><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>安装完成之后，会在 redis 文件夹爱中产生一个 <code>redis.conf</code> 配置文件，把它移到 <code>/etc/redis/</code> 中,修改其中内容进行配置。</p><pre><code> $ sudo cp redis.conf /etc/redis</code></pre><p>配置文件中需要注意的如下（修改过后）：</p><pre><code>bind 127.0.0.1                             # 默认绑定ip  port 6379                                  # 默认端口daemonize yes                              # 是否为守护进程（默认为no）logfile &quot;/var/log/redis/redis-server.log&quot;  # 日志文件（需要新建）databases 16                               # 默认16个数据库，编号0-15dbfilename dump.rdb                        # 数据文件dir /var/lib/redis                         # 数据文件存储路径（需要新建）slaveof                                    # 主从配置</code></pre><h2 id="redis服务端和客户端的启动"><a href="#redis服务端和客户端的启动" class="headerlink" title="redis服务端和客户端的启动"></a>redis服务端和客户端的启动</h2><p>服务端命令为 <code>redis-server</code>,<code>redis-server --help</code> 可查看帮助文档。<br>启动与关闭服务器如下：</p><pre><code>$ sudo redis-server /etc/redis/redis.conf  # 指定加载的配置文件，启动服务器$ ps aux | grep redis                      # 查看进程pid$ sudo kill -9 pid                         # 杀死服务器，即关闭</code></pre><p>客户端命令为 <code>redis-cli</code>,<code>redis-cli --help</code> 可查看帮助文档。<br>直接输入 <code>redis-cli</code> 即可连接服务端，输入 <code>ping</code> 起到检查连接的作用。</p><pre><code>$ redis-cli127.0.0.1:6379&gt; pingPONG</code></pre><p>利用 <code>select</code> 命令切换制定数据库，如：</p><pre><code>select 5</code></pre><h1 id="redis数据操作"><a href="#redis数据操作" class="headerlink" title="redis数据操作"></a>redis数据操作</h1><p><a href="doc.redisfans.com">redis命令大全</a> 很多命令可以去查找</p><p>以下代码有公式形式，匹配例子。</p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>设置的健不存在则添加，存在则修改。</p><ul><li>设置键值<pre><code>  set key value  set name itcast</code></pre></li><li>设置键值及过期时间，以秒为单位<pre><code>  setex key seconds value  setex aa 3 aa</code></pre></li><li>设置多个键值<pre><code>  mset key1 value1 key2 value2 ...  mset a1 python a2 java a3 c</code></pre></li><li>追加值<pre><code>  append key value  append a1 haha</code></pre></li><li>根据键获取值，如果不存在则返回 <code>nil</code> <pre><code>  get key  get name</code></pre></li><li>获取多个键的值<pre><code>  mget key1 key2 ...  mget a1 a2 a3</code></pre><h2 id="键命令"><a href="#键命令" class="headerlink" title="键命令"></a>键命令</h2></li><li>查找键，参数支持正则表达式<pre><code>  keys pattern  keys *       # 查看所有键  keys ‘a*’    # 包含 a 的键</code></pre></li><li>判断键是否存在，存在返回1，否则返回0<pre><code>  exists key1  exists a1</code></pre></li><li>查看对应的值的类型<pre><code>  type key  type a1</code></pre></li><li>删除键及对应的值<pre><code>  del key1 key2 ...   del a2 a3</code></pre></li><li>设置过期时间，以秒为单位<pre><code>  expire key seconds  expire &#39;a1&#39; 3</code></pre></li><li>查看有效时间<pre><code>  ttl key  setex bb 10 bb  ttl bb</code></pre></li></ul><h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>hash 用于存储对象，对象的结构为属性，值。值的类型为string。</p><ul><li>设置单个属性<pre><code>  hset key field value  hset user name itheima  # 如果报错，则表示为数据库快照，可执行下面命令使数据持久化  config set stop-writes-on-bgsave-error no</code></pre></li><li>设置多个属性<pre><code>  set key field1 value1 field2 value2  set u2 name itcast age 11</code></pre></li><li>获取指定键（对象）所有的属性<pre><code>  hkeys key  hkeys u2</code></pre></li><li>获取一个属性的值<pre><code>  hget key field  hget u2 name</code></pre></li><li>获取多个属性的值<pre><code>  hmget key field1 field2  hmget u2 name age</code></pre></li><li>获取所有属性的值<pre><code>  hvals key  hvals u2</code></pre></li><li>删除整个hash键及值，使用  <code>del</code> 命令</li><li>删除属性，属性对应的值会被一起删除<pre><code>  hdel key field1 field2 ...  hdel u2 age</code></pre></li></ul><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p>列表的元素类型为 <code>string</code>，按照插入顺序排序。</p><ul><li>在左侧插入数据<pre><code>  lpush key value1 value2 ...  lpush a1 a b c</code></pre></li><li>在右侧插入数据<pre><code>  rpush key value1 value2 ...  rpush a1 0 1</code></pre></li><li>在指定元素的前或后插入新元素<pre><code>  linsert key before或after 现有元素 新元素  linsert a1 before b 3</code></pre></li><li>获取列表里制定范围内的元素<pre><code>  lrange key start stop  lrange a1 0 -1</code></pre></li><li>设置指定索引位置的元素值<pre><code>  lset key index value  lset a 1 z</code></pre></li><li>删除指定元素<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>irem key count value</code></pre></li></ul></li></ul><h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p>无序集合，元素为 string 类型， 唯一性，不重复。对于集合没有修改操作。</p><ul><li>添加元素<pre><code>  sadd key member1 member2 ...  sadd a3 zhangsan sili wangwu</code></pre></li><li>返回所有元素<pre><code>  smembers key  smember a3</code></pre></li><li>删除指定元素<pre><code>  srem key memebr1  srem a3 wangwu</code></pre></li></ul><h2 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h2><p>有序集合，元素为 string 类型， 唯一性，不重复。每个元素都会关联一个double类型的score，表示权重。通过权重将元素从小到大排序，和 set 一样没有修改操作。</p><ul><li>添加元素<pre><code>  zadd key score1 member1 score2 member2 ...  sadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</code></pre></li><li>返回指定范围内元素<pre><code>  zrange keyy start stop  zrange a4 0 -1</code></pre></li><li>返回 score 值在 min 和 max 之间的元素（闭区间）<pre><code>  zrangebyscore key min max  zrangebyscore a4 5 6</code></pre></li><li>查看某 member 的 score 值<pre><code>  zscore key member  zscore a4 zhangsan</code></pre></li><li>萨和年初指定元素<pre><code>  zrem key member1 member2 ...  zrem a4 zhangsan</code></pre></li><li>删除 score 值在 min 和 max 之间的元素（闭区间）<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>zremrangebyscore key min maxzremrangebyscore a4 5 6</code></pre></li></ul></li></ul><h1 id="redis与python的交互"><a href="#redis与python的交互" class="headerlink" title="redis与python的交互"></a>redis与python的交互</h1><p><a href="python.jobbole.com">redis.py参考文档</a></p><p>StrictRedis 对象方法能操作 string 类型</p><pre><code>sr = StrictRedis(host = &#39;localhost&#39;, port = 6379, db = 0)# 上述都为默认值，可简写sr = StrictRedis()</code></pre><p>根据不同的类型，拥有不同的实例方法可以调用，与前面的 redis 命令对应，方法的参数与命令的参数也一致。</p><h2 id="查看rdb文件"><a href="#查看rdb文件" class="headerlink" title="查看rdb文件"></a>查看rdb文件</h2><p>redis存储下来的数据文件是 <code>dump.rdb</code>，用vim打开是一堆乱码，在个github上发现了，查看rdb文件的工具。<a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools</a> 执行以下命令，可以以json形式查看数据。</p><pre><code>rdb -c json dump.rdb</code></pre><p>由于rdb是一种快照备份，在客户端修改数据过后，不会立即在dump.rdb中显示出来，若想立刻看到，需要在客户端执行<code>BGSAVE</code>异步后台保存，再查看就可以了。注：conf文件中有快照的配置，如下：</p><pre><code># 如果不备份就将 下边3个参数注释掉# 刷新快照到硬盘，必须满足两者要求才会触发save 900 1     # 即900秒之后至少1个关键字发生变化save 300 10    # 必须是300秒之后至少10个关键字发生变化save 60 10000  # 必须是60秒之后10000个关键字发生变化</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10+Ubuntu20.04双系统搭建过程</title>
      <link href="/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/"/>
      <url>/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>鬼知道我这两天重启了多少次电脑，那个小洞都快被我插烂了。。。</p><hr><p>因为有需求要用Ubuntu系统，之前用虚拟机实在是太卡了，索性下定决心装上双系统，总共用了将近2天时间才搞定，下面记录一下装机过程。（要是放图就太多了，不放了，步骤很详细）</p><hr><h2 id="提前准备的东西："><a href="#提前准备的东西：" class="headerlink" title="提前准备的东西："></a>提前准备的东西：</h2><ol><li>注意在装双系统之前要有一个空的盘和一和空的U盘，装机的过程会使之格式化，所以有重要文件一定要备份好。</li><li>下载一个U盘引导盘制作工具 rufus 软件。</li><li>下载好想下载的系统安装包，可以去官网下载或者找阿里云也可，我下的是最新版的 ubuntu20.04，是iso镜像文件。</li></ol><hr><h2 id="一-修改BIOS"><a href="#一-修改BIOS" class="headerlink" title="一. 修改BIOS"></a>一. 修改BIOS</h2><p>首先要进入 BIOS，不同电脑进入的方式可能会不一样，开机时按 <code>F12</code> 或 <code>F2</code> 可能会进入，但是我试了很多按法都没进去，索性直接在关机时用针插入电脑侧边的小洞（有恢复图标），最好找长一点的，太短了会没有反应。打开 BIOS 之后要做的是允许引导写入，做法是进入 BIOS，然后进入 Security，将 Secure Boot 从 Enable 改称 Disable。最后按 <code>F10</code>，保存自动重启电脑。</p><h2 id="二-制作引导盘"><a href="#二-制作引导盘" class="headerlink" title="二. 制作引导盘"></a>二. 制作引导盘</h2><p>插上空的U盘，打开 rufus 软件，在设备处选择自己插的U盘，在引导类型选择处选择系统安装包，目标系统类型 BIOS 或 UEFI，然后就可以开始了，然后点击OK之后，引导盘就制做好了。</p><h2 id="三-利用引导盘装系统"><a href="#三-利用引导盘装系统" class="headerlink" title="三. 利用引导盘装系统"></a>三. 利用引导盘装系统</h2><p>在关机的情况下插上U盘，同样插那个小孔，这次选择启动菜单 boot menu，选择用U盘来启动，进入 Ubuntu 。然后就按引导的步骤来，选中文，地区正常安装等等，注意在选择安装类型的时候选其他选项。这样我们就会自己来进行分区了。我们能看到空闲是非常小的。如果能到达这一步了，说明没什么问题，这个时候重启电脑，进入 Win10，终于要把 ubuntu 装进电脑了，我这里是装进了空的E盘。</p><p>进入 Win10 之后，右击此电脑，选择管理，进入磁盘管理，能看到电脑有几个盘有哪些空间，右击想装的盘，我这里是E盘，删除磁盘，删除之后就会显示有好大的空间没有分配了。而这些空间就是我们要重新分配的。</p><p>重启进入 ubuntu，回到 ubuntu 分区那一步骤，我们能看到空闲空间变得很大。我们就要分配这些空间，每次分区都先点击空闲，再点击加号。由于只讲步骤，这里先不谈 linux 的分区，下面几个分区一定不要弄错。</p><ol><li>建立 swap 交换空间，取8G，设置为主分区和空间起始位置；</li><li>建立 EFI 系统分区，取300M，设置为逻辑分区和空间起始位置；</li><li>建立 /home 分区，取150G，设置为逻辑分区和空间起始位置；</li><li>建立 /usr 分区，取100G，设置为逻辑分区和空间起始位置；</li><li>建立 / 分区，取剩下所有，设置为逻辑分区和空间起始位置。</li></ol><p>安装启动引导器的设备选 /dev/sda4，接下来就可以继续安装，按提示重启电脑了。如果设备理想兼容的话，再次重启就能进入系统选择了。然而我遇到了ubuntu系统卡紫屏的问题。。。</p><h2 id="四-修改内核参数解决卡紫屏"><a href="#四-修改内核参数解决卡紫屏" class="headerlink" title="四. 修改内核参数解决卡紫屏"></a>四. 修改内核参数解决卡紫屏</h2><p>查资料是显卡驱动的问题，之前用的 NVIDIA 显卡驱动，和新系统不适配。</p><p>紫屏时只能按电源关机，再重启进入引导页面时，按 <code>e</code> 键进入 <code>grub</code> 页面，在其中找到开头是linux的一行，再最后加上 <code>nomodeset</code> 这样能暂时禁用所有显卡驱动，<code>F10</code> 保存退出，就能正常打开ubuntu系统了，别忘了系统要更新，输入以下命令即可：</p><pre><code> $ sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre><p>更新之后最好再重启一下电脑，这时还得加上 <code>nomodeset</code> 才能打开，打开后搜索 <code>drivers</code> 就能看到额外驱动标签页，打开之后就能看到有很多可选择的驱动，而默认的并不是 NVIDIA，所以我们改称 NVIDIA，这样就不用每次开机都要修改内核参数了。</p><h2 id="五-两个小问题"><a href="#五-两个小问题" class="headerlink" title="五. 两个小问题"></a>五. 两个小问题</h2><ol><li><p>刚装完之后会遇到每次开机直接进入windows的情况</p><p> 查资料得知，因为 Windows 现在是快速启动， Windows8以上的系统关机实际上不是以前的关机，而是休眠，因此下次开机实际上是从休眠中恢复，因此是直接进入 Windows 。因此把快速启动关掉就可以了。</p></li><li><p>打开 ubuntu 再进入 Win10，总会比正常时间差 8 个小时</p><p> 查资料得知，Windows 和 Ubuntu 的时间设置方式是不一样的，造成了这种错误。在 Ubuntu 中把计算机硬件时间改成系统显示的时间，即禁用Ubuntu的UTC：</p><pre><code> timedatectl set-local-rtc 1 --adjust-system-clock</code></pre><p> 然后再重启电脑进入 Windows 修改时间即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 双系统，Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
