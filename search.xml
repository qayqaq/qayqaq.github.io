<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ST89S51硬件结构</title>
      <link href="/2020/09/17/at89s51-ying-jian-jie-gou/"/>
      <url>/2020/09/17/at89s51-ying-jian-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>嵌入式课以 ST89S51 芯片为例讲解了单片机，有很多没接触过的知识，课后就想着没什么体系地把记着的东西存下来。</p><p>整个硬件结构包含<strong>ALU 微处理器来控制逻辑，SFR 是特殊功能寄存器，RAM 是数据存储器，ROM/EPROM 是程序存储器，P0 P1 P2 P3 是 I/O口，还有串口，中断，定时器资源</strong>。</p><h3 id="关于-P0"><a href="#关于-P0" class="headerlink" title="关于 P0"></a>关于 P0</h3><ul><li>稍微细致来讲，P0 口是由<strong>LATCH</strong>和<strong>PORT0 DRIVER</strong>，通过<strong>driver</strong>这个词是<strong>驱动</strong>，代表了与能量有关，这里有一个点是，单片机输出的 0 和 1 不只依赖于单片机自身，不是我写程序让它输出 1 就会输出 1,如果把端口接了地，就不会输出 1，所以是<strong>需要单片机和外部设备匹配的</strong>。 </li><li>在谈论 P0 P1 P2 P3 时最好要加上语境，在硬件中代表接口，但是在软件中是寄存器，它们四个各<strong>代表一个字节</strong>，P0.0 P0.1 P0.2 … P0.6 P0.7 分别是<strong>一个字节的 8 位</strong>，P0.0 就是 P0 寄存器的最低位。令 <em>P0=00x0</em> 就是输出8个0。</li><li>对 P0.0(AD0) 代表了引脚的<strong>分时复用</strong>，A 与 D 分别代表 <strong>address地址总线</strong>和<strong>data数据总线</strong>，AD0 就代表了总线的第 0 位，最大是 A15 则代表地址总线的带宽是 15。</li></ul><h3 id="AT89S51的新增功能"><a href="#AT89S51的新增功能" class="headerlink" title="AT89S51的新增功能"></a>AT89S51的新增功能</h3><p>按照老师讲，AT89S51 也已经是比较老的芯片，但是很基本，它与之前的 AT89C51 相比有以下改进：</p><ul><li>增加了 ISP（In System Program）</li><li>增加了一个数据指针，增加灵活性</li><li>增加了看门狗定时器</li><li>增加了断电标志</li><li>增加了掉电状态下的中断回复模式</li></ul><h3 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h3><p>引脚大致可以分为三类：</p><ul><li><p>控制类：$\overline{EA}/VPP$，$ALE/\overline{PROG}$，$\overline{PSEN}$，$RST$</p><ul><li>$\overline{PSEN}$ 是片外程序存储器读选通信号，低电平有效</li><li>$ALE$ 当单片机正常运行时，此端口有正脉冲输出，此频率为时钟振荡器频率的 $\frac{1}{6}$，这可以<strong>用于检查硬件故障。</strong><blockquote><p>一些引脚的功能是与扩展有关的，但是现在的趋势是直接换芯片，而不扩展。</p></blockquote></li></ul></li><li><p>I/O口类</p></li><li><p>电源与时钟类：$VSS$，$VDD$，$XTAL1$，$XTAL2$，$T0$，$T1$</p><ul><li>如果用晶振与微调电容，则$XTAL1$，$XTAL2$都需要接</li><li>如果用外部时钟源（多CPU同步的情形），则$XTAL1$接信号，$XTAL2$悬空</li><li>单片机开始工作，需要有三个条件：<strong>电源，晶振，复位</strong>，因此电源，晶振，复位，再加上 MCU 和 register 就构成了<strong>单片机的最小系统。</strong></li></ul></li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li><strong>算数逻辑运算单元 ALU</strong> 可以进行 1. 逻辑运算 2. 算数运算 3. 位操作，其中位操作是比较快的（在嵌入式编程中要考虑时间与空间的节省）</li><li><strong>程序计数器PC</strong> 存指令的地址，16位，复位后归为 <strong>0000H</strong>即回到最开始开始执行指令。</li></ul><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li><p><strong>ROM，程序存储器</strong>，CPU运行时不能更改，断电后信息不变，用于存放程序和常数。</p></li><li><p><strong>RAM，数据存储器</strong>，CPU运行时暂存数据的地方，掉电后丢失。</p><blockquote><p>片内 RAM 可以分为 <strong>1. 工作寄存器区 2. 位寻址区 3. 通用RAM区 4. SFR区</strong>，其中通用RAM区就是存放临时变量的地方，SFR区就是控制单片机上各种资源与功能的寄存器区，很重要，可以说，<strong>操作单片机就是操作SFR。</strong></p></blockquote></li></ul><h3 id="并行口驱动LED发光二极管"><a href="#并行口驱动LED发光二极管" class="headerlink" title="并行口驱动LED发光二极管"></a>并行口驱动LED发光二极管</h3><p>应该用<strong>低电平驱动</strong>，利用灌电流，因为一般单片机输出功率能力不强，但承受能力较强。</p><p>我太菜了 wtcl</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大三返校后随笔</title>
      <link href="/2020/09/06/da-san-fan-xiao-hou-sui-bi/"/>
      <url>/2020/09/06/da-san-fan-xiao-hou-sui-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="疫情返校后的假期杂记"><a href="#疫情返校后的假期杂记" class="headerlink" title="疫情返校后的假期杂记"></a>疫情返校后的假期杂记</h1><p>经历了史上最长的假期，我终于在昨天返回了学校，昨天基本一直在收拾宿舍，今天中午像往常一样睡不着，遂起床想写个随笔，记录一下我还能想起来的，我认为值得记录下的琐事。</p><hr><p>第一件就是“天天向上组织”。在假期的时候，学习效率很低，自制力也越来越差，于是打算去家附近的图书馆每天自习，结果竟然发现，有一些高中和初中同学也在这里自习，大家有的准备考研，有的准备毕业工作，都在努力学习，有比较熟络的，也有初中之后就再也没见过的，但是经过了着一个假期，大家的关系都亲近了起来，就这样成为了一个组织。</p><p>这个书房我在高考之后就去过，那时还没什么名气，去的人也不多。因为疫情，大家都回不去学校，结果附近的人就都去那里学习了，每天都要早去占座。还好我们的组织中有同学能够起床很早哈哈，每天都能占到座位。中午也可以在旁边的食堂吃饭，真的是特别方便，这一段日子简直是找回了在学校学习的效率和感觉，甚至要更好，因为即使在学校，更多的时候也是自己一个人学习，说实话感觉到了一种陪伴，没有那么孤单。</p><p>开学之前，大家也都聚了几次餐，还在电影院白嫖看了场电影，也算是好事坏事都一起干了。我们还约好了以后放假回家仍然一起自习。对我这个不擅长社交的人来说，我真的太喜欢这样了，真切地希望我们能够一直继续下去。</p><hr><p>打麻将也是一件很开心的事，我初高中的时候可以说是特别爱打麻将了，上了大学之后也没有人可以一起玩，就不怎么玩了。这次放假回家和高中同学们打了几次麻将，很惊讶现在的打法和原来的差了好多，而且大家现在也开始实打实的赢钱了。虽然打麻将还是很欢乐的，但是想来，也确实是好久没和一些高中同学有来往了，即使真的聊天，也不知道该聊什么，听说大家还是有几个群的，麻将群，王者群，篮球群，每天在一起闲聊扯淡液是不错的，我也真的是很感谢很多同学，在聚餐的时候想起来叫上我，能减少一些在生活中我心中对他人的疏离感。</p><p>我现在最珍惜的应该就是这段时间建立起的朋友圈，我比较害怕再失去这些朋友，也不是很爱结交新朋友。</p><hr><p>这段时间还报了个英语口语班，虽然想出国的念头不断被国际形势和特朗普也许还有我心中不断萌发的爱国情怀消磨，但是我觉得在国内也是应该把口语学好。这个教育机构的理念大概就是模仿重复表现再反复练习，老师称这是最好的学习口语的体系模式，毕竟人家是教英语的教育机构，把教学方法说的再好也是正常，经过了解之后我还是挺认可的，但是我的思路没那么复杂，我感觉无非是把文本一遍一遍背熟即可。老师还很强调表演，我则非常排斥，并且很惊奇为什么班上很多同学都那么热衷且活跃。</p><p>和一个同学聊过之后发现，可能真的是生长和学习环境造就了一个人，我在一个四线小城市长大，其实是挺自卑的，但是在北京我却知道了英语固然重要，但是也只是一个工具，有很多东西远比英语重要的多，国家科技发展也绝不是把什么语音语调练到极致就可以了。但是这个同学说她之前在农村读书，当得知了我在北京上大学之后，很高兴地说有了一个谈资。</p><p>我真的极其赞赏他们的积极乐观态度，这也是我不具有的。永远不要唉声叹气，境遇不如自己的人有那么多，他们还都在积极学习生活。但是不得不说我本身与这个机构的理念和价值观差的很多，无法说谁对谁错，只是各行各业需要不同性格不同能力的人罢了，我明确我需要所得什么就可以了。</p><hr><p>因为高考之后就没再回来看过老师，所以临开学之前，和两个同学一起回到了高中去看望班主任。老师之前和我们说我们这届之后就不再当班主任了，说太累了，但是今年，学校把各个班在校榜名列前茅的学生聚了起来组成了一个小班让她来代班了，可见我的班主任多么受认可，我极其有幸能成为她的学生。</p><p>我们回首过去，谈到未来，还对比了当时的我们和现在的她的学生，时而发笑时而深思，看着在晚自习的学弟学妹们，真的比较感慨，一时又说不上来什么，最终值得感叹高中时光是多么美好，身边的人时一辈子里最后的真正意义上的同学，而早晚这些人里面也有很多会渐行渐远。</p><p>老师还邀请我给不久后的高三誓师大会录了视频，给学弟学妹们加油打气，我也认真准备了稿子，将高考的现实性和重要性说给他们听，如果能有任何一个人有那么一点触动，我都很满足。</p><hr><p>假期学了一些 HTML CSS Javescript 主要是前端的东西，还过了一遍线性代数，看了部分机器人的知识。都说利用网络进行学习更方便了，但是我感觉我陷入了一个怪圈，看完网课自己往往没记住什么，学什么都不成体系，一些编程语言，如果不经常实践，慢慢都会遗忘，最后选择再看一遍网课。也许多实践才能学好知识吧。</p><hr><h3 id="我们登上并非我们所选择的舞台，拿着并非我们所选择的剧本，我有两个选择，第一种是弃演，第二种就是努力把这个剧本演好。"><a href="#我们登上并非我们所选择的舞台，拿着并非我们所选择的剧本，我有两个选择，第一种是弃演，第二种就是努力把这个剧本演好。" class="headerlink" title="我们登上并非我们所选择的舞台，拿着并非我们所选择的剧本，我有两个选择，第一种是弃演，第二种就是努力把这个剧本演好。"></a>我们登上并非我们所选择的舞台，拿着并非我们所选择的剧本，我有两个选择，第一种是弃演，第二种就是努力把这个剧本演好。</h3>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新增的转换过渡动画</title>
      <link href="/2020/08/18/css3-xin-zeng-de-zhuan-huan-guo-du-dong-hua/"/>
      <url>/2020/08/18/css3-xin-zeng-de-zhuan-huan-guo-du-dong-hua/</url>
      
        <content type="html"><![CDATA[<p>CSS3 中新增了三大类样式，转换，过渡，动画。学习这三种样式的前提是 a 标签的伪类选择器。</p><h2 id="a-标签的伪类选择器"><a href="#a-标签的伪类选择器" class="headerlink" title="a 标签的伪类选择器"></a>a 标签的伪类选择器</h2><ul><li><code>:link</code> 可以修改从未被访问过状态的样式</li><li><code>:visited</code> 访问过状态</li><li><code>:hover</code> 悬停状态</li><li><code>:active</code> 长按状态</li></ul><p>注意：如果同时出现了上述的几个选择器，则<strong>必须遵循上述的顺序。</strong></p><p>如果默认状态的样式和被访问过状态的样式一样，可以缩写为 <code>a {...}</code>而不用再写<code>:link</code>和<code>:visited</code>。</p><p>习惯上，伪类选择器写在标签选择器后面，和a标签盒子相关的属性都写在标签选择器中（显示模式/宽度/高度/padding/margin），和a标签中文字/背景相关的都写在伪类选择器中。</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h3><p>利用伪类选择器，写出过渡的最后状态，如<code>div {width: 100px} div:hover {width: 300px}</code></p><p>再满足过渡三要素，就可以发生过渡：</p><ul><li>必须要有属性发生变化</li><li>必须告诉系统哪个属性需要执行过渡效果</li><li>必须告诉系统过渡效果持续时长</li></ul><p>transition还有两个属性：</p><ul><li><code>transition-delay</code>表示延迟多久后再开始过渡</li><li><code>transition-timing-function</code>表示过渡的速度，取值有：<code>linear/ease/ease-in/ease-out/ease-in-out/cubic-bezier(x1,y1,x2,y2)</code></li><li><code>transition</code>简写方式：<em>过渡属性 过渡时长 运动速度 延迟时间</em> <code>transition: widthc5s linear 0s, background-color 5s ease 0s;</code></li></ul><p>注意：当多个属性需要同时执行过渡效果时用逗号隔开即可：<code>transition-property: width, background-color; transition-duration: 5s,5s;</code></p><p>如果多个属性运动的速度/延迟时间/持续时间都一样，可以利用<code>transition: all ...;</code></p><h3 id="编写过渡的套路"><a href="#编写过渡的套路" class="headerlink" title="编写过渡的套路"></a>编写过渡的套路</h3><ol><li>不要管过渡，先编写基本页面；</li><li>修改我们认为需要需改的属性；</li><li>回过头，去给被修改属性的那个元素添加过渡即可。</li></ol><h2 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h2><h3 id="transform属性"><a href="#transform属性" class="headerlink" title="transform属性"></a>transform属性</h3><ul><li>旋转：<code>transform: rotate(45deg);</code>顺时针旋转45度，注意此时自身坐标系跟着旋转；</li><li>缩放：<code>transform: scale(a,b);</code>沿着自身坐标系水平和竖直方向缩放 a，b 倍，注意<strong>父元素被拉伸了，那么子元素也会被拉伸</strong>；</li><li>平移：<code>transform: translate(x,y);</code>沿着自身坐标系的水平和竖直方向平移 x，y。</li><li>综合写法：<code>transform: rotate(45deg) translate(100px,0px) scale(1.5);</code>注意，进行多个变换时，用<strong>空格</strong>隔开，且旋转之后的平移不再是水平的。</li></ul><p><strong>清除转换可以使用<code>transform: none;</code></strong></p><h3 id="transform-origin形变中心点"><a href="#transform-origin形变中心点" class="headerlink" title="transform-origin形变中心点"></a>transform-origin形变中心点</h3><p>默认情况下，所有的元素都是以自己的中心点作为参考来旋转，可以通过形变中心点属性来修改这个参考点。<code>transform-origin: x y;</code>这里 x，y 可以用 px，%，或者 center 等方位此来表示。</p><h3 id="旋转的轴向"><a href="#旋转的轴向" class="headerlink" title="旋转的轴向"></a>旋转的轴向</h3><p> <code>rotate</code>默认是绕 z轴旋转，等价于<code>rotateZ()</code>，还有<code>rotateX()</code>，<code>rotateY()</code>。</p><h3 id="透视属性"><a href="#透视属性" class="headerlink" title="透视属性"></a>透视属性</h3><p> 透视，近大远小，<code>perspective: x;</code>表示举例 x 远进行观察，对上述的rotateX 和 rotateY 可以加上 perspective 属性就会很容易观察。</p><p> 注意：透视属性<strong>必须添加到待观察元素的父元素或祖先</strong>，而不能放到自身。</p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><p> <code>box-shadow: 水平偏移 垂直偏移 模糊度 阴影扩展 阴影颜色 内外阴影</code><br> 注意：盒子阴影分为内和外，默认是外阴影。阴影颜色由盒子内的<strong>文字颜色</strong>决定。快速添加阴影<strong>只需前三个参数。</strong></p><h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p> <code>text-shadow: 水平偏移 垂直偏移 模糊度 阴影颜色</code><br> 颜色同上。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><p>动画与过渡类似，区别在于，过渡必须人为触发才能执行动画，而动画则不用人为触发。并且动画和过渡一样都需要满足三要素。</p><ul><li>告诉系统要执行哪个动画<code>animation-name: qay</code>； </li><li>自己创建一个叫做 qay 的动画，创建有两种方式，<strong>fromto和百分比</strong>;<pre><code>  @keyframes qay {      from {...}      to {...}  }  @keyframes qay {      0% {}      20% {} ...      70% {}      100% {}  }</code></pre></li><li>告诉系统动画持续的时长<code>animation-duration: 3s</code>.</li></ul><p>动画模块还有几个属性：</p><ul><li><code>animation-delay</code>和transition一样；</li><li><code>animation-timing-function</code>和transition一样；</li><li><code>animation-iteration-count</code>表示动画执行次数，<code>infinite</code>表示无限次；</li><li><code>animation-direction</code>表示是否往返，<code>normal</code>（默认）或<code>alternate</code>,注意往返算执行2次；</li><li><code>animation-play-state</code>控制动画状态，<code>running</code>（默认）表示动画运动，<code>paused</code>表示暂停；</li><li><code>animation-fill-mode</code>其实动画时可以分成三个状态的，如果加上延迟，可以发现有一个<strong>等待状态</strong>，还有<strong>执行状态</strong>，<strong>结束状态</strong>。这个属性的作用是<strong>指定动画等待状态和结束状态的样式</strong>。，取值有:<ul><li><code>none</code>默认，无改变；</li><li><code>backward</code>让动画在等待状态时显示第一帧；</li><li><code>forward</code>让动画在结束状态时显示最后一帧；</li><li><code>both</code>以上两者效果结合。</li></ul></li><li><code>animation</code>简写方式：<em>名称 时长 速度 延迟 重复次数 是否往返</em></li></ul><p>注意点：</p><ol><li>动画中如果有和默认样式中同名的属性，会覆盖默认样式中同名的属性；</li><li>因为会覆盖，可以把这个默认的样式拿到 fromto 中来，但是在编写动画的时候一定要<strong>把固定不变的值写在前面，需要变化的值写在后面。</strong></li></ol><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><p>和透视一样，如果想看到某个元素的3d效果，需要给他的父元素添加<code>transform-style: preserved-3d;</code></p><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="背景尺寸属性"><a href="#背景尺寸属性" class="headerlink" title="背景尺寸属性"></a>背景尺寸属性</h3><p>背景尺寸属性是CSS3中新增的一个属性，专门用于设置背景图片。</p><ul><li>默认，不加操作，显示原图大小；</li><li>具体像素，<code>background-size: 100px 100px;</code></li><li>百分比，<code>background-size: 80% 50%;</code></li><li>宽度等比拉伸，<code>background-size: auto 100px;</code></li><li>高度等比拉伸，<code>background-size: 100px auto;</code></li><li>cover，<code>background-size: cover;</code>等比拉伸，且拉伸到<strong>宽度和高度</strong>都填满整个元素；</li><li>contain，<code>background-size: contain;</code>等比拉伸，且拉伸到<strong>宽度或高度</strong>填满整个元素；</li></ul><h3 id="背景图片定位区域属性"><a href="#背景图片定位区域属性" class="headerlink" title="背景图片定位区域属性"></a>背景图片定位区域属性</h3><ul><li>padding-box（默认从padding开始显示）<code>background-origin: padding-box;</code></li><li>border-box，从边框开始显示<code>background-origin: border-box;</code></li><li>content-box，从内容开始显示<code>background-origin: content-box;</code></li></ul><h3 id="背景绘制区域的属性"><a href="#背景绘制区域的属性" class="headerlink" title="背景绘制区域的属性"></a>背景绘制区域的属性</h3><ul><li>padding-box，从padding开始显示<code>background-clip: padding-box;</code></li><li>border-box，（默认从border开始显示）<code>background-clip: border-box;</code></li><li>content-box，从内容开始显示<code>background-clip: content-box;</code></li></ul><h3 id="多重背景图片"><a href="#多重背景图片" class="headerlink" title="多重背景图片"></a>多重背景图片</h3><p>多张背景图片之间用<strong>逗号隔开即可</strong>，<strong>先添加的图片会盖住后添加的</strong>，但是可以通过背景定位来分开。</p><p>当一个盒子中有很多背景图片，都用逗号隔开时，编写很麻烦，建议在编写多重背景时分开写。</p><h2 id="超大图片"><a href="#超大图片" class="headerlink" title="超大图片"></a>超大图片</h2><p>因为现在显示器各种各样，所以在准备类似封面或者广告图片的时候一般都会准备超大的图片，然后把重要的内容放在中间而两边一般是纯色。</p><p>在这种情况下，往往图片元素的大小就会超过了父元素的大小，而这时如果想设置图片居中的话，无论是在自身样式中设置<code>margin: 0 auto;</code>还是在父元素样式中设置<code>text-align: center;</code>都会失效。</p><p>解决办法有两种：</p><ul><li>可以通过在定位中的居中办法，即设置<code>left:50%; margin-left: -自身宽度的一半;</code></li><li>更推荐的一种是，在父元素样式中设置<code>text-align: center;</code>，然后再自身样式中设置<code>margin:0 -100%;</code>，然后因为图片过大默认会产生滚动条，所以可以在父元素样式中设置<code>overflow: hidden;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS样式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非线性控制理论知识梳理</title>
      <link href="/2020/08/17/fei-xian-xing-kong-zhi-li-lun-zhi-shi-shu-li/"/>
      <url>/2020/08/17/fei-xian-xing-kong-zhi-li-lun-zhi-shi-shu-li/</url>
      
        <content type="html"><![CDATA[<p>最近学习了非线性控制理论，把笔记存下来。</p><h2 id="Lyapunov-Direct-Method-李雅普诺夫直接方法"><a href="#Lyapunov-Direct-Method-李雅普诺夫直接方法" class="headerlink" title="Lyapunov Direct Method 李雅普诺夫直接方法"></a>Lyapunov Direct Method 李雅普诺夫直接方法</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/1.jpg" alt=""></p><h2 id="The-Invariance-Principle-LaSalle’s-Theorem-拉塞尔不变性原理"><a href="#The-Invariance-Principle-LaSalle’s-Theorem-拉塞尔不变性原理" class="headerlink" title="The Invariance Principle - LaSalle’s Theorem 拉塞尔不变性原理"></a>The Invariance Principle - LaSalle’s Theorem 拉塞尔不变性原理</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/2.jpg" alt=""></p><h2 id="Basic-Feedback-Stabilization-基本非线性系统稳定性设计"><a href="#Basic-Feedback-Stabilization-基本非线性系统稳定性设计" class="headerlink" title="Basic Feedback Stabilization 基本非线性系统稳定性设计"></a>Basic Feedback Stabilization 基本非线性系统稳定性设计</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/3.jpg" alt=""></p><h2 id="Nonlinear-Backstepping-Controller-反布法控制器"><a href="#Nonlinear-Backstepping-Controller-反布法控制器" class="headerlink" title="Nonlinear Backstepping Controller 反布法控制器"></a>Nonlinear Backstepping Controller 反布法控制器</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/4.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/5.jpg" alt=""></p><h2 id="Nonlinear-Adaptive-Controller-自适应控制器"><a href="#Nonlinear-Adaptive-Controller-自适应控制器" class="headerlink" title="Nonlinear Adaptive Controller 自适应控制器"></a>Nonlinear Adaptive Controller 自适应控制器</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/6.jpg" alt=""></p><h2 id="Sliding-Mode-in-Robust-Control-鲁棒控制中的滑模控制"><a href="#Sliding-Mode-in-Robust-Control-鲁棒控制中的滑模控制" class="headerlink" title="Sliding Mode in Robust Control 鲁棒控制中的滑模控制"></a>Sliding Mode in Robust Control 鲁棒控制中的滑模控制</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/7.jpg" alt=""></p><h2 id="High-Gain-and-High-Frequency-Control-鲁棒控制中的高增益和高频控制"><a href="#High-Gain-and-High-Frequency-Control-鲁棒控制中的高增益和高频控制" class="headerlink" title="High Gain and High Frequency Control 鲁棒控制中的高增益和高频控制"></a>High Gain and High Frequency Control 鲁棒控制中的高增益和高频控制</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/nonlinear_control/8.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性控制理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从分类器开始谈到Yolo</title>
      <link href="/2020/08/13/cong-fen-lei-qi-kai-shi-tan-dao-yolo/"/>
      <url>/2020/08/13/cong-fen-lei-qi-kai-shi-tan-dao-yolo/</url>
      
        <content type="html"><![CDATA[<p>搞懂一个网络模型，最重要的就是三个部分：</p><ul><li><strong>前向计算</strong></li><li><strong>损失函数</strong></li><li><strong>反响传播</strong></li></ul><p>其中最重要的就是如何进行前向计算，我们要搞懂网络中的数据如何从前向后计算；至于损失函数这一部分，我们还要思考<strong>如何组织样本数据</strong>，构造函数表示预测值与标记值的差异，常用的由 MSE 和交叉熵。</p><p>本文不涉及数学推导，从最简单的分类器说起，逐步改进，最终得到基础版的 Yolo，也是现在 Yolo5 的基础。</p><p>要处理的对象都是<strong>图片</strong>。</p><h2 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h2><p>分类模型需要将一张图片进行归类。</p><p>分类模型的输入是一个矩阵，输出是一个 onehot 向量，其过程可以简写为：</p><p><strong>img3 -&gt; cbrp16 -&gt; cbrp32 -&gt; cbrp64 -&gt; cbrp128 -&gt; […] -&gt; fc256 -&gt; fc10</strong></p><p>上述过程，完成了 rgb 3通道图片分为 10 类的过程，很好理解。那么检测器的构造是否可以利用分类器呢？</p><h2 id="检测器"><a href="#检测器" class="headerlink" title="检测器"></a>检测器</h2><p>检测模型需要对一张给定的图片中的内容是否为指定物体进行检测，如果是的话，要求用方框框出来。</p><p>检测模型的输入仍然是一个矩阵，而要输出一个框，那么应该如何用数学方式表达这个框呢？</p><p>方法有很多，比如对角的两个点 (p1,p2)，或者用中心点和宽高 (Cx,Cy,w,h)，或者用一个定点和宽高 (x,y,w,h)，有的情景输出的是旋转后的框，那么就要再加一个输出量 angle。</p><p>有了输入和输出，如何构造检测器呢？</p><p>我们的方案是<strong>遍历性分类</strong>：遍历所有大小与位置，对每个框都执行分类器就可以了，但是缺点也很明显：<strong>耗时严重</strong>。</p><p>这种方案就是传统检测器的思路，其本质仍然是分类器，是一个<strong>背景与前景（如人脸）的而二分类</strong>，这里注意我们不可能各个大小的窗口都训练一个分类器，而是要归一化所有的框再传进分类器。</p><p>这里还有一个问题就是，在训练样本的过程中显然<strong>背景图片多，前景图片少</strong>，<strong>二分类样本不均衡</strong>，这是一个很值得改善的问题。</p><p>我们看到了传统检测器的缺陷，那么如何改进呢？</p><h2 id="直接拟合结果的检测"><a href="#直接拟合结果的检测" class="headerlink" title="直接拟合结果的检测"></a>直接拟合结果的检测</h2><p>有一个方法是很显然的，既然分类器的输出结果 onehot 向量也可以看成是神经网络拟合得出的分类结果，那么为什么不能直接通过神经网络拟合出框的位置呢？</p><p>在输出结果时，经常还输出一个量，<strong>置信度confidence</strong>，所以我们将 onehot 向量，换成一个 (c,x,y,w,h) 这样的向量作为输出，直接确定位置：</p><p><strong>img3 -&gt; cbrp16 -&gt; cbrp32 -&gt; cbrp64 -&gt; cbrp128 -&gt; […] -&gt; fc256 -&gt; fc5(c,x,y,w,h)</strong></p><p>接下来，同理通过计算 (c,x,y,w,h) 与 样本事先的(c,x,y,w,h)* 之间的 loss，再通过反向传播，不断调整** conv 中的 w，b 和 BN 中的 $\alpha$，$\beta$**，最终训练出检测器。</p><p>到了这里的检测器已经能稍微快一些的检测目标了，但是显然只能检测到一个目标，那么多目标怎么办呢？</p><h2 id="基于直接拟合的多目标检测"><a href="#基于直接拟合的多目标检测" class="headerlink" title="基于直接拟合的多目标检测"></a>基于直接拟合的多目标检测</h2><p>一个很直接的想法就是输出 N 个 (c,x,y,w,h)，那么输出多少合适呢？显然，为了能都检测到，我们要<strong>尽可能输出多的框</strong>：</p><p><strong>img3 -&gt; cbrp16 -&gt; cbrp32 -&gt; cbrp64 -&gt; cbrp128 -&gt; […] -&gt; fc256 -&gt; fc[5✖N][(c,x,y,w,h)✖N]</strong></p><p>如何比较好的取 N？由于采用的是卷积网络，<strong>多组输出与位置强相关，所以要采用按空间位置来映射</strong>，比如，将图片均分 3✖4，那么 N=W✖H=3✖4，网络的输出就是 3✖4✖5 这样的三维矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/1.png" alt=""></p><p>刚才也说了，我们为了尽可能得到所有检测结果，就要取很多框，这里最多就取了12个框，但是如果真实照片没有这么多袋检测的物体，比如一张人脸正好在分界线上，则有两个框都表示这一张脸，这个问题如何解决？</p><p><strong>NMS 算法</strong>应运而生，抑制最大值算法，核心思想<strong>使用 IoU 来算重合度</strong>，来进行不同框之间的聚类，不能再聚类时就得到了最终结果。</p><p>输出已经时三维了，已经有点复杂了，我们在这里说一下如何表示损失函数，包含了置信度 c 的 c_loss 和几何位置的损失 geo_loss：</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/2.png" alt=""></p><hr><p>到这里我们已经可以检测多目标了，但是如果要同时检测多类呢？</p><h2 id="多类多目标检测"><a href="#多类多目标检测" class="headerlink" title="多类多目标检测"></a>多类多目标检测</h2><p>说到类别就是 onehot 向量，显然我们只需要扩展输出结果的每个(c,x,y,w,h)，在其后面加上一个 onehot 向量，若要分两类：</p><p><strong>img3 -&gt; cbrp16 -&gt; cbrp32 -&gt; cbrp64 -&gt; cbrp128 -&gt; […] -&gt; fc256 -&gt; fc[(5+2)✖N][(c,x,y,w,h,onehot)✖N]</strong></p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/3.png" alt=""></p><p>损失函数也只是在之前的基础上多了一个类别上带来的损失：</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/4.png" alt=""></p><p>到这里感觉如果不考虑速度只考虑需求貌似已经比较好了，但是<strong>检测模型有一个通病：小目标检测不佳</strong>，要如何改善呢？</p><h2 id="改善小目标检测不佳的检测器（Yolo基本版）"><a href="#改善小目标检测不佳的检测器（Yolo基本版）" class="headerlink" title="改善小目标检测不佳的检测器（Yolo基本版）"></a>改善小目标检测不佳的检测器（Yolo基本版）</h2><p>方案就是<strong>专门设计神经元来拟合小目标。</strong></p><p>网络结构变为：</p><p><strong>img3 -&gt; cbrp16 -&gt; cbrp32 -&gt; cbrp64 -&gt; cbrp128 -&gt; […] -&gt; fc256 -&gt; fc[(5+5+2)✖N][(c,x,y,w,h,c‘,x’,y‘,w’,h‘,onehot)✖N]</strong></p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/5.png" alt=""></p><p>简单说就是，若为大目标，则前面的 (c,x,y,w,h) 来预测，后面的置信度为 0 ，若为小目标，则后面的 (c,x,y,w,h) 来预测，前面的置信度为 0 。这样分开来改善。那么问题就是，怎么区分大目标还是小目标呢。</p><p>当然时人为界定，我们给定一个大框，一个小框，当检测出的框的大小处在大框和小框之间时，利用 <strong>IoU</strong> 来计算重合度来判定。</p><p>一路改进到了这里，就是基本的 Yolo 了。最后放出几张论文的图片，论文中的 loss 函数写的比较复杂，难以理解，还是按照遍历图片，遍历行，遍历列比较好理解，最后拆开写和论文中就是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/6.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/7.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Yolo/8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波笔记</title>
      <link href="/2020/08/13/qia-er-man-lu-bo-bi-ji/"/>
      <url>/2020/08/13/qia-er-man-lu-bo-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>首先讨论了关于<strong>测量的数学构造</strong>，得到一个递推式，在推导卡尔曼滤波公式时应用了相同原理。</p><p>然后分别讨论了，<strong>数据融合</strong>，<strong>协方差矩阵</strong>，<strong>状态空间表达</strong>。其中数据融合就是根据测量值和分布确定最优值，这也是卡尔曼滤波滤去噪声得到最优解的根本思想。</p><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/1.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/2.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/3.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/4.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/5.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/Kalman_filter/6.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式整理</title>
      <link href="/2020/08/12/css-yang-shi-zheng-li/"/>
      <url>/2020/08/12/css-yang-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>以下为常用总结，更精细的参考官方文档：<a href="https://www.w3school.com.cn/cssref/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/index.asp</a></p><h2 id="常用CSS文本样式"><a href="#常用CSS文本样式" class="headerlink" title="常用CSS文本样式"></a>常用CSS文本样式</h2><ul><li><code>color</code>设置文字颜色;</li><li><code>font-size</code>设置文字大小;</li><li><code>font-family</code>设置文字字体;</li><li><code>font-style</code>设置文字是否倾斜，<code>normal</code>，<code>italic</code>;</li><li><code>font-weight</code>设置文字是否加粗，<code>normal</code>，<code>bold</code>;</li><li><code>line-height</code>设置文字行高，相当于文字的上下同时加间距;</li><li><code>font</code>可以同时设置文字几个属性，顺序：<em>是否倾斜 是否加粗 字号/行高 字体</em>；</li><li><code>text-decoration</code>设置文字下划线，<code>none</code>去掉下划线;</li><li><code>text-indent</code>设置文字首行缩进，<code>text-indent: 24px;</code>;</li><li><code>text-align</code>设置文字水平对齐方式，<code>center</code>居中;</li></ul><h2 id="CSS颜色表示法"><a href="#CSS颜色表示法" class="headerlink" title="CSS颜色表示法"></a>CSS颜色表示法</h2><ul><li><strong>颜色名</strong>，如<code>red</code>；</li><li><strong>rgb表示</strong>，如<code>rgb(255,0,0)</code>；</li><li><strong>16进制表示</strong>，如<code>#ff0000</code>；</li></ul><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ul><li><strong>标签选择器</strong>：影响较大，建议用在层级选择器中；</li><li><strong>id选择器</strong>：id不能重复；</li><li><strong>类选择器</strong>：最常用；</li><li><strong>层级选择器</strong>：主要用于选择父元素下的子元素，由<strong>空格</strong>分隔；</li><li><strong>组选择器</strong>：多个选择器有同样格式，用组选择器，由<strong>逗号</strong>分隔；</li><li><strong>伪类及伪元素选择器</strong>：<pre><code>  .box1:hover{color:red;}  .box2:before{content:‘行首文字’;}  .box3:after{content:‘行尾文字’;}</code></pre></li></ul><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p><img src="https://www.runoob.com/images/box-model.gif" alt=""></p><p>把元素称为盒子，设置对应的样式为：<strong>宽度(width)，高度(height)，边框(border)，盒子的内容与边框的间距(padding)，盒子与盒子之间的间距(margin)。</strong></p><ol><li>设置宽高<ul><li><code>width: 200px;</code> <strong>此宽度是盒子内容的宽度，不是整体的宽度</strong></li><li><code>height: 200px;</code> <strong>此高度是盒子内容的宽度，不是整体的高度</strong></li></ul></li><li>设置边框<ul><li><code>border-top-color: red;</code></li><li><code>border-top-width: 10px;</code></li><li><code>border-top-solid: solid;</code> 常用的还有<code>dashed</code>，<code>dotted</code></li><li>简写：<code>border-top: 10px red solid;</code></li><li>设置其他边框同理，如果设置四个边框直接<code>border: 10px red solid;</code></li></ul></li><li>设置内间距<ul><li>可以分别设置，如<code>padding-top: 20px;</code></li><li>也可以一起设置，如<code>padding: 20px 40px 50px 30px</code>，为上右下左</li><li>跟 3 个值为，上，左右，下</li><li>根 2 个值为，上下，左右</li><li>根 1 个值为，上下左右</li></ul></li><li>设置外边距：基本设置方法同上，有一些技巧与需要注意的地方<ul><li>设置元素水平居中 <code>margin: (x) auto;</code></li><li>margin设置<strong>负值</strong>可以让元素位移及边框合并</li><li><strong>外边距合并</strong>是指，当两个<strong>垂直外边距</strong>相遇时，它们将形成一个外边距。合并后的外边距高度等于其中的较大者，解决方法如下：<ul><li>就利用这种特性，不修改</li><li>只设置一边的外边距，一般设置<code>margin-top</code></li><li>将元素<strong>浮动或定位</strong></li></ul></li><li><strong>margin-top塌陷</strong>是指，当两个盒子嵌套的时候，内部的盒子设置的<code>margin-top</code>会加到外边的盒子上，导致内部的盒子<code>margin-top</code>设置失败，解决方法如下：<ul><li>外部盒子设置一个边框</li><li>外部盒子设置<code>overflow hidden</code></li><li>使用伪元素类<pre><code>  .clearfir:before{      content: &quot;&quot;;      display: table;  }</code></pre></li></ul></li></ul></li></ol><h2 id="CSS元素溢出"><a href="#CSS元素溢出" class="headerlink" title="CSS元素溢出"></a>CSS元素溢出</h2><p>当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的方式，通过<code>overflow</code>属性设置：</p><ul><li><code>visible</code>默认值，内容不会被修剪，会呈现在元素框之外</li><li><code>hidden</code>内容会被修剪，且其余内容不可见，此属性还有清除浮动，清除margin-top塌陷的功能</li><li><code>scroll</code>内容会被修剪，但是浏览器会显示滚动条以便查看其余内容</li><li><code>auto</code>如果内容被修剪，则浏览器会显示滚动条以便查看其余内容</li><li><code>inherit</code>从父元素继承overflow的值</li></ul><h2 id="CSS元素种类"><a href="#CSS元素种类" class="headerlink" title="CSS元素种类"></a>CSS元素种类</h2><ul><li>块元素：如 <code>div, p, ul, li, h1~h6, dl, dt, dd</code>等都是块元素，特性：<ul><li>支持全部样式</li><li>如果没有设置宽度，<strong>默认宽度为父级的100%</strong></li><li><strong>盒子占据一行，即使设置了宽度</strong></li></ul></li><li>内联元素：如<code>a, span, em, b, strong, i</code>等都是行内元素，特性：<ul><li>支持部分样式，<strong>不支持宽高，margin上下，padding上下</strong></li><li><strong>宽高由内容决定</strong></li><li>盒子并在一行</li><li><strong>代码换行，盒子会产生间距</strong>，解决产生间隙的方法：<ul><li>去掉内联元素之间的换行</li><li>将内联元素的父级设置<code>font-size: 0;</code>，内联元素自身再设置<code>font-size</code></li></ul></li><li>子元素是内联元素，父元素可以通过<code>text-align</code>设置子元素水平对其方式，</li></ul></li><li>内联块元素:<code>input</code>和<code>img</code>元素的行为类似这种元素，但是他们也归类于内联元素，可以用<code>display</code>属性转化，特性：<ul><li>支持全部样式 </li><li>如果没有设置宽高，宽高由内容决定</li><li>盒子并在一行</li><li>代码换行，盒子会产生间距</li><li>子元素是内联块元素，父元素可以通过<code>text-align</code>设置子元素水平对其</li></ul></li></ul><p><strong>以上三种元素，都可相互转化，但是实际开发中块元素用的较多，所以经常把内联元素转化为块元素，少量转化为内联；需要使用内联元素时，直接使用内联元素，而不用块元素转化了。</strong></p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>浮动分为左右<code>float: left;</code> <code>float: right;</code>，特性：</p><ul><li>浮动的元素会向左或向右浮动，<strong>碰到父元素边界，或其他元素才停下来</strong></li><li>相邻浮动的<strong>块元素可以并在一行</strong>，超出父级宽度就换行</li><li>浮动让行内元素或块元素<strong>自动转化为行内块元素，且不会有行内块元素间隙问题</strong></li><li>浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成<strong>文字绕图</strong>的效果</li><li>浮动元素之间<strong>没有margin的合并</strong></li><li>父元素如果没有设置尺寸（一般是高度不设置），父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动</li><li>清除浮动方法：<ul><li>父级上增加属性<code>overflow: hidden;</code></li><li>在最后一个子元素的后面加上一个空的div，给他样式属性<code>clear: both;</code>（不推荐）</li><li>使用成熟的清除浮动样式类,<code>clearfix</code>:<pre><code>  .clearfix:after, .clearfix:before{ content: &quot;&quot;; display: table;}  .clearfix:after{ clear: both;}  .clearfix{zoom: 1;}</code></pre></li><li>清除浮动的使用方法：<pre><code>  .con2{... overflow: hidden;}  # 或者  &lt;div class=&quot;con2 clearfix&quot;&gt;</code></pre></li></ul></li></ul><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流，是指盒子按照html标签编写顺序依次从上到下，从左到右排列，块元素占一行，行内元素在一行之内从左到右排列，先写的先排列，后写的排在后面，每个盒子都占据自己的位置。</p><p>可以使用<code>position</code>属性来设置元素定位类型：</p><ul><li><code>inherit</code>继承父元素<code>position</code>值</li><li><code>relative</code>生成相对定位元素，元素所占据的<strong>文档流位置保留</strong>，元素本身相对自身原位置进行偏移 </li><li><code>absolute</code>生成绝对定位元素，元素脱离文档流，不占据文档流位置，可以理解为漂浮在文档流的上方，相对于上一个设置了定位的父级元素进行定位，如果找不到，则相对于<code>body</code>元素进行定位</li><li><code>fixed</code>生成固定定位元素，元素脱离文档流，不占据文档流位置，可以理解为漂浮在文档流的上方，相对于浏览器窗口进行定位</li><li><code>static</code>默认值，不定位，保持原样</li></ul><p><strong>绝对定位和固定定位</strong>的块元素和行内元素会<strong>自动转化为行内块元素</strong>。</p><p><strong>定位元素的偏移</strong>：用<code>left, right, top, bottom</code>设置偏移值。</p><p><strong>定位元素层级</strong>：定位元素是浮动于正常文档流之上的，可以用<code>z-index</code>设置层级。</p><pre><code>.box {    position: absolute;    left: 200px;    top: 100px;    z-index: 10;}</code></pre><h2 id="background属性"><a href="#background属性" class="headerlink" title="background属性"></a>background属性</h2><p>负责给盒子设置背景图片和背景颜色，是复合属性，分为：</p><ul><li><code>background-color</code>颜色</li><li><code>background-image</code>图片地址</li><li><code>background-repeat</code>背景图如何平铺</li><li><code>background-position</code>背景图片位置</li><li><code>background-attachment</code>设置背景图片是固定还是随页面滚动条滚动</li><li>简写，如：<code>background: #00FF00 url(bgimage.gif) no-repeat left center fixed</code></li></ul><h2 id="CSS权重"><a href="#CSS权重" class="headerlink" title="CSS权重"></a>CSS权重</h2><p>指样式的优先级，有两条或多条样式作用于同一个元素，权重高的样式起作用，权重相同的，采取<strong>就近原则</strong>。等级如下：</p><ul><li><code>!important</code>加在样式属性后，权重为 <strong>10000</strong></li><li>内联样式，如：<code>style=&quot;&quot;</code>，权重为 <strong>1000</strong></li><li>id选择器，如:<code>#content {}</code>，权重为 <strong>100</strong></li><li>类，伪类和属性选择器，如<code>content, hover</code>，权重为 <strong>10</strong></li><li>标签选择器和伪元素选择器，如<code>div, p, before</code>，权重为 <strong>1</strong></li><li>通用选择器(<em>)，自选择器(&gt;)，相邻选择器(+)，同胞选择器(~)，权重为 *</em>0**</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS样式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代控制理论知识梳理</title>
      <link href="/2020/08/11/xian-dai-kong-zhi-li-lun-zhi-shi-shu-li/"/>
      <url>/2020/08/11/xian-dai-kong-zhi-li-lun-zhi-shi-shu-li/</url>
      
        <content type="html"><![CDATA[<p>最近学习了现代控制理论，把笔记存下来。</p><h2 id="State-Space-Representation-状态空间表达"><a href="#State-Space-Representation-状态空间表达" class="headerlink" title="State-Space Representation 状态空间表达"></a>State-Space Representation 状态空间表达</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/1.jpg" alt=""></p><h2 id="Phase-Portrait-相图-相轨迹"><a href="#Phase-Portrait-相图-相轨迹" class="headerlink" title="Phase Portrait 相图 相轨迹"></a>Phase Portrait 相图 相轨迹</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/2.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/3.jpg" alt=""></p><h2 id="Controllability-可控性"><a href="#Controllability-可控性" class="headerlink" title="Controllability 可控性"></a>Controllability 可控性</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/4.jpg" alt=""></p><h2 id="Stability-稳定性"><a href="#Stability-稳定性" class="headerlink" title="Stability 稳定性"></a>Stability 稳定性</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/5.jpg" alt=""></p><h2 id="Linear-Controler-Design-线性控制器设计"><a href="#Linear-Controler-Design-线性控制器设计" class="headerlink" title="Linear Controler Design 线性控制器设计"></a>Linear Controler Design 线性控制器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/6.jpg" alt=""></p><h2 id="Linear-Quadratic-regulator-LQR控制器"><a href="#Linear-Quadratic-regulator-LQR控制器" class="headerlink" title="Linear Quadratic regulator LQR控制器"></a>Linear Quadratic regulator LQR控制器</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/7.jpg" alt=""></p><h2 id="Follow-a-Desired-Path-轨迹跟踪"><a href="#Follow-a-Desired-Path-轨迹跟踪" class="headerlink" title="Follow a Desired Path 轨迹跟踪"></a>Follow a Desired Path 轨迹跟踪</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/8.jpg" alt=""></p><h2 id="Linear-Observer-Design-状态观测器设计"><a href="#Linear-Observer-Design-状态观测器设计" class="headerlink" title="Linear Observer Design 状态观测器设计"></a>Linear Observer Design 状态观测器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/9.jpg" alt=""></p><h2 id="Oberservability-and-Seperation-Principle-可观测性和分离原理"><a href="#Oberservability-and-Seperation-Principle-可观测性和分离原理" class="headerlink" title="Oberservability and Seperation Principle 可观测性和分离原理"></a>Oberservability and Seperation Principle 可观测性和分离原理</h2><p><img src="https://cdn.jsdelivr.net/gh/qayqaq/qayqaq.github.io/image/advanced_control/10.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代控制理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django其他一些技术</title>
      <link href="/2020/08/05/django-qi-ta-yi-xie-ji-zhu/"/>
      <url>/2020/08/05/django-qi-ta-yi-xie-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>网页里使用的 css, js, images属于于静态文件。</p><ul><li>新建静态文件夹<code>static</code>。</li><li>配置静态文件所在的物理目录。<code>settings.py</code><ul><li><code>STATIC_URL</code>设置访问静态文件对应的url；</li><li><code>STATICFILES_DIRS</code>设置静态文件所在的物理目录</li></ul></li><li>动态生成静态文件路径<pre><code>  &lt;!DOCTYPE html&gt;  {% load staticfiles %}  # 加载静态文件  &lt;html lang=&quot;en&quot;&gt;      &lt;img src=&quot;{% static 'images/123.jpg' %}&quot;&gt;  # 动态拼接静态文件路径  &lt;/html&gt;</code></pre></li><li>加载目录：先去配置的statics目录找，没找到再去各个应用下的statics目录找。</li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件函数是django框架给我们预留的函数接口，让我们可以干预请求和应答的过程。</p><p>中间件函数会在每一个视图函数执行前执行，所以我们可以修改或定义中间件函数来达到某向目的，比如：禁止某个 ip 地址访问所有网页，这个功能是可以通过装饰器实现的，但是需要在每个视图函数前面都加上装饰，很麻烦，而用中间件函数则很方便。</p><pre><code>EXCLUDE_IPS = []def blocked_ips(view_finc):    def wrapper(request, *view_args, **view_kwargs):        user_ip = request.META[&#39;REMOTE_ADDR&#39;]        if user_ip in EXCLUDE_IPS:            return HttpResponse(&#39;&lt;h1&gt;Forbidden&lt;h1&gt;&#39;)        else:            return view_finc(request, *view_args, **view_kwargs)    return wrapper@blocked_ipsdef static_test(request):    print(settings.STATICFILES_FINDERS)    # &#39;django.contrib.staticfiles.finders.FileSystemFinder&#39;, \    # &#39;django.contrib.staticfiles.finders.AppDirectoriesFinder&#39;    return render(request, &#39;booktest/static_test.html&#39;)@blocked_ipsdef index(request):    return render(request, &#39;booktest/index.html&#39;)</code></pre><ul><li><p>获取浏览器端的 ip 地址<br>  使用 request 对象的 META 属性： <code>request.META[&#39;REMOTE_ADDR&#39;]</code></p></li><li><p>在应用中新建<code>middleware.py</code></p></li><li><p>定义中间件类，在类中定义中间件预留函数，包括：</p><ul><li><p><code>__init__</code>: 服务器响应<strong>第一个请求</strong>的时候调用；</p></li><li><p><code>process_request</code>: 是在产生 request 对象，进行 url 匹配之前调用；</p></li><li><p><code>process_view</code>: 是 url 匹配之后，处理视图函数之前；</p></li><li><p><code>process_response</code>: 视图函数调用之后，内同返回给浏览器之前；</p></li><li><p><code>process_exception</code>: 视图函数出现异常，会调用这个函数；</p><p>以上叙述即是<strong>正常工作流程</strong>：浏览器向django第一次发送请求，django产生一个request同时执行<code>__init__</code>，之后执行<code>process_request</code>，之后进行url匹配，之后执行<code>process_view</code>，之后调用视图函数，之后执行<code>process_response</code>，之后给出相应，在过程中若视图函数异常，执行<code>process_exception</code>。</p><p>如果注册的多个中间件类中包含<code>process_exception</code>时，调用的顺序根注册的<strong>顺序是相反的</strong>。</p><pre><code># middleware.pyclass BlockedIPSMiddleWare(object):  EXCLUDE_IPS = []  def process_view(self, request, view_func, *view_args, **veiw_kwargs):      user_ip = request.META[&#39;REMOTE_ADDR&#39;]      if user_ip in BlockedIPSMiddleWare.EXCLUDE_IPS:          return HttpResponse(&#39;&lt;h1&gt;Forbidden&lt;h1&gt;&#39;)class TestMiddleWare(object):  def __init__(self):      print(&#39;----init----&#39;)  def process_request(self, request):      print(&#39;----process_request----&#39;)  def process_view(self, request, view_func, *view_args, **view_kwargs):      print(&#39;----process_view----&#39;)  def process_response(self, request, response):      print(&#39;----process_reponse----&#39;)      return responseclass ExceptionTest1MiddleWare(object):  def process_exception(self, request, exception):      print(&#39;----process_exception1----&#39;)      print(exception)class ExceptionTest2MiddleWare(object):  def process_exception(self, request, exception):      print(&#39;----process_exception2----&#39;)</code></pre></li></ul></li><li><p>注册中间件类：结合前面所说的顺序问题，当视图函数发生异常时，先执行<code>ExceptionTest2MiddleWare</code>。</p><pre><code>  MIDDLEWARE_CLASSES = (      &#39;booktest.middleware.BlockedIPSMiddleWare&#39;,      &#39;booktest.middleware.TestMiddleWare&#39;,      &#39;booktest.middleware.ExceptionTest1MiddleWare&#39;,      &#39;booktest.middleware.ExceptionTest2MiddleWare&#39;,  )</code></pre></li><li><p>还有一点需要注意的是，如果在流程中的任意位置返回了<code>response</code>，则<strong>直接跳到整个流程的最后一步</strong>，执行<code>process_response</code>，之后给出相应，这也是为什么最开始的装饰器可以达到干预应答的效果的原因。</p></li></ul><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><pre><code># models.pyclass AreaInfo(models.Model):    asize = models.BooleanField(default=False)    atitle = models.CharField(verbose_name=&#39;标题&#39;, max_length=20)    aParent = models.ForeignKey(&#39;self&#39;, null=True, blank=True)    def __str__(self):        return self.atitle    def title(self):        return self.atitle    title.admin_order_field = &#39;atitle&#39;    title.short_description = &#39;地区名称&#39;    def parent(self):        if self.aParent is None:            return &#39;&#39;        return self.aParent.atitle    parent.short_description = &#39;父级地区名称&#39;</code></pre><pre><code># admin.pyfrom booktest.models import AreaInfoclass AreaStackedInline(admin.StackedInline):    model = AreaInfo  # 多类名字    extra = 2class AreaTabularInline(admin.TabularInline):    model = AreaInfo  # 多类名字    extra = 2class AreaInfoAdmin(admin.ModelAdmin):    list_per_page = 10    list_display = [&#39;id&#39;, &#39;atitle&#39;, &#39;title&#39;, &#39;parent&#39;]    actions_on_bottom = True    actions_on_top = False    list_filter = [&#39;atitle&#39;]    search_fields = [&#39;atitle&#39;]    # fields = [&#39;aParent&#39;, &#39;atitle&#39;]    fieldsets = (        (&#39;基本&#39;, {&#39;fields&#39;:[&#39;atitle&#39;]}),        (&#39;高级&#39;, {&#39;fields&#39;:[&#39;aParent&#39;]})    )    inlines =  [AreaStackedInline]    # inlines = [AreaTabularInline]admin.site.register(AreaInfo, AreaInfoAdmin)</code></pre><h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><ul><li><p>配置上传文件保存目录</p><ul><li>新建<code>media</code>文件夹</li><li><code>MEDIA_ROOT = os.path.join(BASE_DIR, &#39;static/media&#39;)</code></li></ul></li><li><p>后台管理页面上传图片</p><ul><li>设计模型类<pre><code>  class PicTest(models.Model):      goods_pic = models.ImageField(upload_to=&#39;booktest&#39;)</code></pre></li><li>迁移生成表格</li><li>注册模型类</li></ul></li><li><p>用户自定义页面上传图片</p><ul><li><p>定义用户上传图片的页面并显示，是一个自定义的表单</p><pre><code>  &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/upload_handle&quot;&gt;      {% csrf_token %}      &lt;input type=&quot;file&quot; name=&quot;pic&quot;&gt;&lt;br&gt;      &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;  &lt;/form&gt;</code></pre></li><li><p>定义接受上传文件的视图函数：request 对象有一个<strong>FILES属性</strong>，类似于字典，通过request.FILES可以获取上传文件的处理对象。当上传文件不大于2.5M，文件放在内存中，若大于2.5M，文件内容写入临时文件中。</p><pre><code>  def show_upload(request):      return render(request, &#39;booktest/upload_pic.html&#39;)  def upload_handle(request):      # 1. 获取上传文件的处理对象      pic = request.FILES[&#39;pic&#39;]      print(type(pic))      # print(pic.name)      # pic.chunks()      # 创建一个文件      save_path = &#39;%/booktest/%s&#39;%(settings.MEDIA_ROOT, pic.name)      with open(save_path, &#39;wb&#39;) as f:          # 获取上传文件的内容 并写到创建的文件中          for content in pic.chunks():              f.write(content)      # 在数据库中保存上传记录      PicTest.objects.create(goods_pic=&#39;booktest/%s&#39;%pic.name)      # 返回      return HttpResponse(&#39;ok&#39;)</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数和装饰器</title>
      <link href="/2020/08/04/gao-jie-han-shu-he-zhuang-shi-qi/"/>
      <url>/2020/08/04/gao-jie-han-shu-he-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数一般分为3种：</p><ol><li>函数作为另一个函数的参数；</li><li>函数作为另一个函数的返回值；</li><li>函数嵌套。</li></ol><p>前两种都比较好理解，举例看第三种：</p><p>调用外部函数是不会直接调用内部函数的，除非在外部函数内内部函数外调用了内部函数，比如下面的<code>return inner</code>其实就是返回了内部函数，所以<code>outer()()</code>实际上执行的就是<code>inner</code>函数。</p><p>对于外部函数内定义的变量<code>x</code>，如果想在内部函数修改，需要关键字<code>nonlocal</code>，易知<code>outer()()</code>会输出<code>20, 11</code></p><pre><code>def outer():    x = 10    def inner():        nonlocal x        y = x + 1        x = 20        print(x,y)    return innerouter()()</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个比较抽象的概念，实际上上面的代码段就是一个闭包，有两个特征：</p><ol><li>外部函数的返回值是内部函数；</li><li>内部函数中操作了外部函数中的变量。</li></ol><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器的基本结构如下，如果想写一个装饰器的话，就先写出这样的结构：</p><pre><code>def cal_time(fn):    def inner():        pass@cal_timedef demo():    pass</code></pre><p>根据以下代码说明装饰器的机理：</p><ol><li>遇见<code>@cal_time</code>即执行<code>cal_time</code>函数，但是这里外部函数中只有内部函数，所以没什么效果；</li><li><code>def demo(n)</code>中的<code>demo</code>函数已经变成了<code>cal_time</code>的参数<code>fn</code>；</li><li><code>m = demo()</code>中的<code>demo</code>函数其实是执行的装饰器函数中的内部函数<code>inner</code>。</li></ol><p><strong>分析：</strong>综合123，我们可以发现，<code>def demo(n)</code>只定义的一个输入参数<code>n</code>，而<code>m = demo(100000000, &#39;good&#39;, y=&#39;hello&#39;)</code>则有这么多参数，是因为这里的<code>demo</code>其实已经是<code>inner(x, *args, **kwargs)</code>，<code>s = fn(x)</code>之所以有输入参数且可以有返回值，是因为<code>def demo(n)</code>定义了一个输入参数且有一个返回值<code>return x</code>。把这两个<strong>替换关系</strong>搞明白了，装饰器就清楚了。</p><pre><code>def cal_time(fn):    def inner(x, *args, **kwargs):        start = time.time()        s = fn(x)        end = time.time()        return s, end - start    return inner@cal_timedef demo(n):    x = 0    for i in range(1,n):        x += i    return xm = demo(100000000, &#39;good&#39;, y=&#39;hello&#39;)print(m)</code></pre><h2 id="装饰器的应用"><a href="#装饰器的应用" class="headerlink" title="装饰器的应用"></a>装饰器的应用</h2><p>上面我们已经看到了，利用装饰器，可以非常方便地求出一个函数的运行时间，在这个函数的上面加上<code>@cal_time</code>然后再执行这个函数即可。</p><p>装饰器还强大在，当想添加需求或有新的输入参数时，可以完全不改动原函数，下面看一个例子，<code>play_game</code>是一个函数表示某人在玩某个游戏。现在想添加功能，超过22点就禁止玩游戏</p><pre><code>def play_game(name, game):    print(&#39;{} is playing {}&#39;.format(name, game))</code></pre><p>首先写出一个装饰器结构，这里的<code>fn</code>代表原来的<code>play_game</code>，而原函数有两个输入参数，所以<code>inner</code>中先传入两个参数<code>x,y</code>，根据新加的功能，至少还要输入时间点，所以再写入<code>*args, **kargs</code>：</p><pre><code>def can_play(fn):    def inner(x, y, *args, **kargs):        pass    return inner</code></pre><p>然后就判断输入的时间点是否超过22点即可，若没超过，执行<code>fn()</code>，完整如下，这样就实现了不改动原来函数的情形下，完成了新需求，利用<code>get</code>方法还可以设定默认值，防止输入时没有输入<code>clock</code>参数，达到了不给时间点，默认不让玩游戏的功能。</p><p>完整代码如下：</p><pre><code>def can_play(fn);    def inner(x, y, args, **kargs):        # if args[0] &lt;= 22:        if kwargs.get(&#39;clock&#39;, 23) &lt;= 22:            fn(x, y)        else:            print(&#39;Too late&#39;)    return inner@can_playdef play_game(name, game):    print(&#39;{} is playing {}&#39;.format(name, game))# play_game(&#39;123&#39;, &#39;abc&#39;, 18)play_game(&#39;123&#39;, &#39;abc&#39;, clock=23)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python，装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的模板</title>
      <link href="/2020/08/03/django-de-mo-ban/"/>
      <url>/2020/08/03/django-de-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="模板的功能"><a href="#模板的功能" class="headerlink" title="模板的功能"></a>模板的功能</h2><p>产生 html，控制页面上展示的内容。模板文件不仅仅是一个 html 文件。 模板文件包含两部分内容：</p><p>（1）静态内容：css，js，html；</p><p>（2）动态内容：用于动态产生一些网页内容，通过<strong>模板语言（简称DTL）</strong>来产生。</p><h2 id="模板文件的使用"><a href="#模板文件的使用" class="headerlink" title="模板文件的使用"></a>模板文件的使用</h2><p>通常是在视图函数中使用模板产生 html 内同返回给客户端，以下几步可以通过<code>render(request, template_path, context={})</code>一句话实现：</p><p>（1）加载模板文件：获取模板文件内容，产生一个模板对象；<code>temp = loader.get_template(&#39;booktest/index.html&#39;)</code></p><p>（2）定义模板上下文：给模板文件传递数据；<code>context = RequestContext(request, {})</code></p><p>（3）模板渲染产生 html 页面内容：用传递的数据替换相应的变量，产生一个替换后的表中 html 内容：<code>res_html = temp.render(context)</code></p><p>（4）返回应答：<code>return HttpResponse(res_html)</code></p><h2 id="模板文件加载顺序"><a href="#模板文件加载顺序" class="headerlink" title="模板文件加载顺序"></a>模板文件加载顺序</h2><p>（1）首先去配置的模板目录下面去找模板文件；<br>（2）去 <code>INSTALLED_APPS</code>下面的每个应用去找模板文件，前提是必须有<code>templates</code>文件夹。</p><h2 id="模板语言——模板变量"><a href="#模板语言——模板变量" class="headerlink" title="模板语言——模板变量"></a>模板语言——模板变量</h2><p>模板变量名是由数字，字母下划线和点组成的，不能以下划线开头。</p><p>使用模板变量：<code></code></p><p>模板变量的解析顺序：</p><ul><li><p>如果是<code>book.btitle</code></p><ol><li>把 book 当成一个字典，把 btitle 当成键名，进行取值 book[‘btitle’]；</li><li>把 book 当成一个对象，把 btitle 当成属性，进行取值 book.btitle；</li><li>把 book 当成一个对象，把 btitle 当成方法，进行取值 book.btitle；</li></ol></li><li><p>如果是<code>book.0</code></p><ol><li>把 book 当成一个字典，把 0 当成键名，进行取值 book[‘0’]；</li><li>把 book 当成一个列表，把 0 当成方下标，进行取值 book[0];</li></ol></li><li><p>如果解析失败，则产生内容时用<strong>空字符串</strong>填充模板变量。</p></li></ul><p><strong>使用模板变量时，前面的可能是一个字典，是一个对象，也可能是一个列表。</strong></p><h2 id="模板标签和内置过滤器"><a href="#模板标签和内置过滤器" class="headerlink" title="模板标签和内置过滤器"></a>模板标签和内置过滤器</h2><ul><li><p>for 循环：</p><pre><code>  {% for x in 列表 %}    # 列表不为空时执行    {% empty %}    # 列表为空时执行    {% endfor %}  # 可以通过 {{ forloop.counter }}得到循环遍历了几次</code></pre></li><li><p>条件判断</p><pre><code>  {% if 条件 %}    {% elif 条件 %}    {% else %}    {% endif %}</code></pre></li><li><p>关系比较操作符<code>&gt; &lt; &gt;= &lt;= == !=</code>，进行比较操作时，<strong>比较操作符两边必须由空格。</strong></p></li><li><p>逻辑运算： <code>not and or</code></p></li><li><p>过滤器：<strong>过滤器用于对模板变量进行操作</strong></p><p>  <strong>date</strong>: 改变日期的显示格式；</p><p>  <strong>length</strong>: 求长度。字符串，列表长度；</p><p>  <strong>default</strong>: 设置模板变量的默认值。</p><p>  格式：<strong>模板变量 | 过滤器： 参数</strong></p><p>  还有<strong>自定义过滤器</strong>，<strong>至少有一个参数，最多有两个参数</strong>。</p><pre><code>  # booktest/tamplatetags/filter.py  # 自定义过滤器  from django.template import Library  register = Library()  @register.filter  def mod(num):      return num%2  @register.filter  def mod_val(num, val):      return num%val ==0  # xxx.html  {% load filter %}  {{ book.btitle|length }}  {{ book.bupadte|date: 'Y年-m月-d日' }}  {% if book.id|mod %}  {% if book.id|mod_var:2 %}</code></pre><p>  具体的查参考文档：<a href="https://yiyibooks.cn/xx/django_182/index.html" target="_blank" rel="noopener">https://yiyibooks.cn/xx/django_182/index.html</a></p></li></ul><h2 id="模板语言——模板注释"><a href="#模板语言——模板注释" class="headerlink" title="模板语言——模板注释"></a>模板语言——模板注释</h2><ul><li>单行注释： ``</li><li>多行注释： <pre><code>  {% comment %}     注释内容     {% endcomment %}</code></pre></li></ul><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>很多网页都有相同的东西，比如导航条版权信息，可以创建一个父模板<code>base.html</code>，再建立很多子模板<code>child.html</code>来继承，只需要在子模板中写入一个语句，就会把父模板中所有内容拿来：</p><pre><code>{% extends 'booktest/base.html' %}</code></pre><p>注意在继承之后，再在子模板中写入各种东西是不会生效的。而子模板与父模板不同的地方，需要在父模板中预留位置，称为<strong>预留块</strong>，这样子模板就可以重写父模板预留块中的内容。预留块的写法以及重写预留块的方法如下：</p><pre><code># base.html{% block 块名 %}    可以写内容，也可以不写{% endblock 块名 %}# child.html{% block 块名 %}    {{ block.super }} # 加上这句话，就会获取父模板中这个块的内容    重写内容{% endblock 块名 %}</code></pre><h2 id="html转义"><a href="#html转义" class="headerlink" title="html转义"></a>html转义</h2><p>在<strong>模板上下文</strong>中的html标记默认是会被转义的。</p><ul><li><code>&lt;</code> 转换为 <code>&amp;lt;</code></li><li><code>&gt;</code> 转换为 <code>&amp;gt;</code></li><li><code>&#39;</code> 转换为 <code>&amp;#39;</code></li><li><code>&quot;</code> 转换为 <code>&amp;quot;</code></li><li><code>&amp;</code> 转换为 <code>&amp;amp;</code></li></ul><p>要关闭模板上下文字符串的转义，可以使用<code></code>；也可以使用:</p><pre><code>{% autoscape off %}模板语言代码{% endautoscape off %}</code></pre><p><strong>模板硬编码中的字符串默认不会转义</strong>，若要转义，需手动。</p><h2 id="csrf攻击"><a href="#csrf攻击" class="headerlink" title="csrf攻击"></a>csrf攻击</h2><p>跨站请求，修改密码。。。csrf伪造有两个关键点：</p><ol><li>登陆正常网站后，你的浏览器保存了sessionid，且没有退出；</li><li>不小心访问了另外一个网站，并且点击了页面上的按钮。。。</li></ol><p>django防止csrf的方式：</p><ol><li>默认打开了<strong>csrf中间件</strong>；</li><li>表单 post 提交数据时要加上 <code>csrf_token</code>标签。<pre><code> &lt;form method=&quot;post&quot;&gt;     {% csrf_token %} &lt;form&gt;</code></pre></li></ol><p><strong>防御原理：</strong></p><ol><li>渲染模板文件时在页面上生成一个名叫 csrfmiddlewaretoken 的隐藏域；</li><li>服务器交给浏览器保存一个名字为 csrftoken 的 cookie 信息。</li><li>提交表单时，两个值都会发送给服务器，服务器进行比对，如果一样，则 csrf 验证通过，否则失败。</li></ol><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><p>当某一个url配置的地址发生变化时，页面上使用反向解析生成地址的位置不需要发生变化。</p><p><strong>根据url正则表达式的配置动态的生成url。</strong></p><ul><li>在项目的根路由中包含具体应用的urls时，<strong>指定namespace</strong>；<pre><code>  urlpatterns = [      url(r&#39;^admin/&#39;, include(admin.site.urls)),      url(r&#39;^&#39;, include(&#39;booktest.urls&#39;, namespace=&#39;booktest&#39;)),  ]</code></pre></li><li>在应用的urls中配置<strong>指定name</strong>；<pre><code>  urlpatterns = [      url(r&#39;^index2/$&#39;, views.index, name=&#39;index&#39;),      url(r&#39;^show_arg/(\d+)/(\d+)/$&#39;, views.show_arg, name=&#39;show_arg&#39;),      url(r&#39;^show_kwarg/(?P&lt;num1&gt;\d+)/(?P&lt;num2&gt;\d+)/$&#39;, views.show_kwarg, name=&#39;show_kwarg&#39;),  ]</code></pre></li><li>在模板文件中使用时，<strong>url标签</strong>；<pre><code>  # {% url 'namespace : name' %}  {% url 'booktest : index' %}  # {% url 'namespace : name' 参数 %}  {% url 'booktest : show_arg' 10 20 %}  # {% url 'namespace : name' 关键字参数 %}  {% url 'booktest : show_arg' num1=10 num2=20 %}</code></pre></li><li>在重定向时使用反向解析:<pre><code>  from django.core.urlresolvers import reverse  def test_reverse(request):      # url = reverse(&#39;booktest:index&#39;)      # return redirect(url)      # url = reverse(&#39;booktest:show_args&#39;, args=(1,2))      # return redirect(url)      url = reverse(&#39;booktest:show_kwargs&#39;, kwargs={&#39;num1&#39;:3, &#39;num2&#39;:4})      return redirect(url)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的视图</title>
      <link href="/2020/08/02/django-de-shi-tu/"/>
      <url>/2020/08/02/django-de-shi-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="视图的功能"><a href="#视图的功能" class="headerlink" title="视图的功能"></a>视图的功能</h2><p>接受请求，进行处理，与 M 和 T 进行交互，返回应答。</p><p>（1）返回 html 内容<code>HttpResponse</code>；</p><p>（2）重定向<code>redirect</code>。</p><h2 id="视图函数的使用"><a href="#视图函数的使用" class="headerlink" title="视图函数的使用"></a>视图函数的使用</h2><p>（1）定义视图函数：<code>request</code>参数必须有。是一个<code>HttpResponse</code>类型的对象。参数名可以变化，但不要更改。</p><p>（2）配置 url，具体见基本应用。</p><h2 id="错误视图"><a href="#错误视图" class="headerlink" title="错误视图"></a>错误视图</h2><p>（1）<strong>404</strong>：<strong>url没有配置或配置错误</strong>找不到页面，关闭调试模式之后，默认会显示一个标准的错误页面，如果要显示自定义页面，则需要在 templates 目录下面自定义一个 404.html 文件</p><p>（2）<strong>500</strong>：<strong>视图出错</strong>服务器端的错误。</p><h2 id="捕获-url-参数"><a href="#捕获-url-参数" class="headerlink" title="捕获 url 参数"></a>捕获 url 参数</h2><p>进行 url 匹配时，把所需要捕获的部分设置成一个<strong>正则表达式组</strong>，这样就会自动把匹配成功后相应组的内容作为参数传递给视图函数。</p><p>（1）<strong>位置参数</strong>：参数名可以随意指定。<code>url(r&#39;^showarg(\d+)&#39;, views.show_arg)</code></p><p>（2）<strong>关键字参数</strong>：在位置参数的基础上给正则表达式组命名即可。<code>url(r&#39;^showarg(?P&lt;num&gt;\d+)&#39;, views.show_arg)</code></p><p>注：？P&lt;组名&gt;，<strong>关键字参数，视图中参数名必须与正则表达式组名一致。</strong></p><h2 id="request-的常用参数"><a href="#request-的常用参数" class="headerlink" title="request 的常用参数"></a>request 的常用参数</h2><p>以下除非特别声明，否则都是只读的。</p><ul><li><code>path</code>: 一个字符串，表示请求的页面的完整路径，不包含域名和参数部分；</li><li><code>method</code>: 一个字符串，表示是 GET 还是 POST；<ul><li>在浏览器中<strong>给出地址</strong>发出请求采用 GET，如超链接；</li><li>在浏览器中<strong>提交表单</strong>发起请求，若表单设置为 POST，则为POST；</li></ul></li><li><code>GET</code>: <code>QueryDict</code>类型对象，类似于字典，包含 get 请求方式所有参数；</li><li><code>POST</code>: <code>QueryDict</code>类型对象，类似于字典，包含 post 请求方式所有参数；</li><li><code>FILES</code>: 一个类似于字典的对象，包含所有上传的文件；</li><li><code>COOKIES</code>: 一个标准的 Python 字典，包含所有的 cookie，键和值都为ie字符串；</li><li><code>session</code>: 一个既可读又可写的类似于字典的对象，表示当前的会话，只有当 django 启用会话的支持时才可用，详细内容后面叙述。</li></ul><p>注：<code>QueryDict</code>可以一个键对应多个值，get方法只会取这个键的最后一个值，getlist方法取出所有。</p><p>给一个提交表单发出请求的实例：</p><pre><code># views.pydef login(request):    return render(request, &#39;booktest/login.html&#39;)def login_check(request):    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# urls.pyurlpatterns = [    url(r&#39;^login$&#39;, views.login),    url(r&#39;^login_check$&#39;, views.login_check),]# login.html&lt;form method=&quot;post&quot; action=&quot;/login_check&quot;&gt;    USERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    PASSWORD&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt;</code></pre><h2 id="状态保持——Cookie"><a href="#状态保持——Cookie" class="headerlink" title="状态保持——Cookie"></a>状态保持——Cookie</h2><p>http协议是无状态的，下一次去访问一个页面时并不知道上一次对这个页面作了什么。而使用Cookie就是类似达到一种保存的功能，本质上cookie是<strong>由服务器生成，存储在浏览器的一小段文本信息</strong>。</p><p>想像你去饭店点菜，点完之后就去网吧玩了，打算估摸菜好了再回来吃；而老板很笨，记不住你点了什么菜，所以老板决定给你发一个小票上面记录了你要吃的所有东西并要求回来时带着小票这样老板就知道你要吃的是什么了。</p><p>在这个过程中，老板在你点菜之后给你小票，就是浏览器像服务器发起请求之后，web服务器生成Cookie信息然后让浏览器保存Cookie信息，再带着小票来，就是浏览器再把cookie发送给服务器，这基本上就是cookie的过程。</p><p>cookie 的特点：</p><p>（1）以<strong>键值对</strong>方式进行存储；</p><p>（2）通过浏览器访问一个网站时，会将浏览器存储的和这个网站相关的<strong>所有cookie信息</strong>发送给该网站的服务器，即<code>request.COOKIES</code>；</p><p>（3）cookie是基于域名安全的；</p><p>（4）cookie是有过期时间的，如果不指定，默认关闭浏览器之后cookie就会过期；</p><p>（5）cookie 无论保存什么值，<strong>取出时都是字符串。</strong></p><p>cookie 的设置：需要一个<code>HttpResponse</code>类的对象，或者是它的子类，<code>HttpReponseRedirect</code>，<code>JsonResponse</code>。可以通过<code>max_age</code>和<code>expires</code>参数设置过期时间。</p><pre><code># views.pydef set_cookie(request):    response = HttpResponse(&#39;set cookie&#39;, max_age=14*24*3600)    # response = HttpResponse(&#39;set cookie&#39;, expires=datetime.now()+timedelta(days=14))    response.set_cookie(&#39;num&#39;, 1)    return responsedef get_cookie(request):    num = request.COOKIES[&#39;num&#39;]    return HttpResponse(num)# urls.pyurlpatterns = [    url(r&#39;^set_cookie$&#39;, views.set_cookie),    url(r&#39;^get_cookie$&#39;, views.get_cookie),]</code></pre><p>在上述登录例子基础上，利用Cookie可以方便地实现<strong>记住用户名</strong>这一功能，只需要在登陆成功后设置cookie，再次显示页面时拿出cookie，并在html页面上设置value值显示即可：</p><pre><code># views.pydef login(request):    if &#39;username&#39; in request.COOKIES:        username = request.COOKIES[&#39;username&#39;]    else:        username = &#39;&#39;    return render(request, &#39;booktest/login.html&#39;, {&#39;username&#39;:username})def login_check(request):    # request.POST    # request.GET    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    remember = request.POST.get(&#39;remember&#39;)    if username == &#39;smart&#39; and password ==&#39;123&#39;:        response = redirect(&#39;/index&#39;)        if remember == &#39;on&#39;:            response.set_cookie(&#39;username&#39;, username, max_age=7*24*3600)        return response        # return redirect(&#39;/index&#39;)    else:        return redirect(&#39;/login&#39;)# login.htmlUSERNAME&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ username }}&quot;&gt;&lt;br&gt;</code></pre><h2 id="状态保持——Session"><a href="#状态保持——Session" class="headerlink" title="状态保持——Session"></a>状态保持——Session</h2><p>想象你去网吧办了一张会员卡，网管给了你一个卡号，然后把你的姓名身份证等信息存储到了网吧电脑的表格里。</p><p>在django中，网吧电脑的表格就是 django_session，这个表格类似于字典，每一个主键对应一些信息，给你的卡号即是主键 session_key，电脑里存下的信息就是 session_data，而网馆给了你一个卡号，其实是服务器给浏览器设置了一个 cookie，这个 cookie 名叫<code>sessionid</code>，是读取session信息的惟一标识码，等再次访问网站时，浏览器获取 sessionid，并根据 sessionid 的值取出对应的 session 信息。而这些信息都在<code>request.session</code>属性中。 </p><p>session 的特点：</p><p>（1）session 是以<strong>键值对</strong>进行存储的，session_data可以在 mysql 数据库中的 django_session 表格中看到，其中 session_data 是经过 base64 编码之后的，解码之后就能看到，设置的键值对；</p><p>（2）session 依赖于 cookie，因为 sessionid 是 cookie；</p><p>（3）也有过期时间，不指定的话，默认两周过期。</p><p>（4）不像 cookie， session <strong>保存进去什么类型，取出就是什么类型.</strong></p><p>（5）session涉及到安全性要求比较高的数据，银行卡密码，账户等。相对而言，cookie安全性要求不高，可以记住用户名。</p><ul><li>session 的设置：<code>request.session[&#39;key&#39;] = value</code></li><li>根据键读取：<code>request.session.get(&#39;key&#39;, default)</code></li><li>清除所有session，在存储中删除值部分：<code>request.session.clear()</code></li><li>清除所有session，在存储中删除session整条数据：<code>request.session.flush()</code></li><li>删除session中指定键和值：<code>del request.session[&#39;key&#39;]</code></li><li>设置会话过期时间：<code>request.session.set_expiry(value)</code><ul><li>value是整数，将在value秒没有活动后过期；</li><li>value是0，将在浏览器关闭时过期；</li><li>value是None，将在两周后过期。</li></ul></li></ul><p>在上述登录例子基础上，利用session可以方便地实现<strong>记住登陆状态</strong>这一功能，只需要在登陆成功后设置session的一个键<code>islogin</code>，再次发出登陆情请求时，如果session表格里由<code>islogin</code>这个键，直接显示登陆成功的页面：</p><pre><code># def login_checkif username == &#39;smart&#39; and password ==&#39;123&#39;:    request.session[&#39;islogin&#39;] = True        return response# def loginif request.session.has_key[&#39;islogin&#39;]:    return redirect(&#39;/index&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django， Cookie， Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的模型</title>
      <link href="/2020/08/02/django-de-mo-xing/"/>
      <url>/2020/08/02/django-de-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="字段属性和选项："><a href="#字段属性和选项：" class="headerlink" title="字段属性和选项："></a>字段属性和选项：</h2><p>列举部分常用的，其余参考官方文档。</p><p>字段类型，使用时需要引入 django.db.models：</p><ul><li><code>Autofield</code>: 自增的，不用指定；</li><li><code>BooleanField</code>: 布尔；</li><li><code>NullBooleanField</code>: 支持 Null 的布尔；</li><li><code>CharField(max_length=)</code>: 字符串；</li><li><code>TextField</code>: 大文本字段，超过4000字；</li><li><code>IntegerField</code>: 整数；</li><li><code>DecimalFIeld(max_digits=None,decimal_places=None)</code>: 十进制浮点数；</li><li><code>FloatField</code>：浮点数，参数同上，没有 Deciaml 精确；</li><li><code>DateField([auto_now=False, auto_now_add=False])</code>: 日期，auto_now 会自动更新最后一次修改数据时间，auto_now_add 会自动添加创建数据时的时间，不可同时使用；</li><li><code>TimeField</code>: 时间，参数同上；</li><li><code>DateTimeField</code>: 日期时间，参数同上；</li><li><code>FileField</code>: 上传文字字段；</li><li><code>ImageField</code>: 继承于 FileField，对上传内容进行校验，确保是有效的图片。</li></ul><p>选项：</p><ul><li><code>default</code>: 设置默认值；</li><li><code>primary_key</code>: 设为主键，默认 False；</li><li><code>unique</code>: 字段在表中必须有唯一值，默认 False；</li><li><code>db_index</code>: 在表中会为此字段创建索引，默认 False；</li><li><code>db_column</code>: 字段名称，如未指定，则使用属性名称；</li><li><code>null</code>: 允许为空，默认 False；</li><li><code>blank</code>: 允许为空白，默认 False；</li></ul><p>注： null是数据库范畴的概念，blank 是后台管理页面表单验证范畴的。</p><p>当修改模型类之后，如果添加的选项不影响表的结构，则不需要重新迁移，default 和 blank 不影响表的结构。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><strong>查询函数：</strong></p><p>通过模型类<code>.objects</code>属性可以调用如下函数，实现对模型类对应的数据表的查询。</p><ul><li><p><code>get</code>: 返回一个模型类对象，参数写查询条件，查不到或者查到多条都会报错；</p></li><li><p><code>all</code>: 返回<code>QuerySet</code>类型； </p></li><li><p><code>filter</code>: 返回<code>QuerySet</code>类型，参数写查询条件； </p></li><li><p><code>exclude</code>: 同上；</p></li><li><p><code>order_by</code>: 返回<code>QuerySet</code>类型，参数写属性，默认从小到大排序，在属性前加‘-’为从大到小；</p><p>  <code>BookInfo.objects.order_by(&#39;-id&#39;)</code></p></li></ul><p><strong>查询条件：</strong></p><p>条件格式：模式类属性名__<strong>条件名</strong>=值</p><ul><li><p>判等 条件名：exact（可省略）<code>BookInfo.objects.get(id__exact=1)</code></p></li><li><p>模糊查询 条件名：contains（包含）endswith（结尾）startswith（开头）<code>BookInfo.objects.filter(btitle__contains=&#39;三&#39;)</code></p></li><li><p>空查询 条件名：isnull <code>BookInfo.objects.filter(id__isnull=False)</code></p></li><li><p>范围查询 条件名：in <code>BookInfo.objects.filter(id__in=[1,3,5])</code></p></li><li><p>比较查询 条件名：gt，lt，gte，lte </p><p>  id大于等于3：<code>BookInfo.objects.filter(id__gte=3)</code></p></li><li><p>日期查询</p><p>  1999年出版：<code>BookInfo.objects.filter(bupdate__year=1999)</code><br>  1980.1.1后出版：<code>BookInfo.objects.filter(bupdate__gt=date(1980,1,1))</code></p></li></ul><h2 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h2><p>作用：用于查询时条件之间的<strong>逻辑关系</strong>。not and or，可用Q对象进行&amp;|～操作。若不使用Q对象，默认写多个条件是且关系。</p><pre><code>from django.db.models import QBookInfo.objects.filter(id__gt=3，bread__gt=30)BookInfo.objects.filter(Q(id__gt=3)|Q(bread__gt=30))BookInfo.objects.filter(～Q(id=3))</code></pre><h2 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h2><p>作用：用于类属性之间的比较。</p><pre><code>from django.db.models import FBookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;))BookInfo.objects.filter(bread__gt=30=F(&#39;bcommet&#39;)*2)</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>作用：对查询结果进行聚合操作。sum count avg max min。调用 aggregate 来聚合，返回一个字典。</p><pre><code>from django.db.models import Sum, Count, Avg, Max, MinBookInfo.objects.all().aggregate(Count(&#39;id&#39;))# {&#39;id__count&#39;: 5}BookInfo.objects.all().aggregate(Sum(&#39;bread&#39;))# {&#39;bread__sum&#39;: 126}</code></pre><p><strong>count</strong>函数返回值是一个数字，也可以统计满足条件数据的数目。</p><pre><code>BookInfo.objects.all().count()BookInfo.objects.count()</code></pre><h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>对一个QuerySet对象，以上函数都可以继续使用。</p><p><strong>查询集特性：</strong></p><ul><li><strong>惰性查询：</strong>只有在实际使用查询集中的数据时才会发生对数据库的真正查询。</li><li><strong>缓存：</strong>当使用的是同一个查询集时，第一次的时候会发生实际数据库的查询。然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。</li></ul><p><strong>限制查询集：</strong><br>可以对一个查询集进行取下标或者切片来限制查询集的结果。</p><p>对一个查询集进行切片会产生<strong>新查询集</strong>，下标<strong>不允许为负数</strong>。</p><p>取出查询集第一条数据：</p><ul><li><code>b[0]</code> 若不存在，报 <code>IndexError</code></li><li><code>b[0:1]</code>.get() 若不存在，报 <code>DoesNotExist</code></li></ul><p>查询集的<strong>exists</strong>方法可以判断是否有数据。</p><h2 id="模型类关系"><a href="#模型类关系" class="headerlink" title="模型类关系"></a>模型类关系</h2><ul><li>多对多：<code>models.ManyToManyField()</code>，定义在哪都行；</li><li>一对一：<code>models.OneToOneField()</code>，定义在哪都行；</li><li>一对多：<code>models.ForeignKey()</code>，定义在多类中。</li></ul><p><strong>一对多的关联查询</strong></p><ul><li>用实例查询：<ul><li>由多查一：<code>h.hbook</code></li><li>由多查一的对象的id：<code>h.hbook_id</code></li><li>由一查多：<code>book.heroinfo_set.all()</code></li></ul></li><li>用模型类实现关联查询<ul><li>通过多类的条件查询一类的数据：<pre><code>  # 一类名.objects.filter(多类名小写__多类名属性__条件名)  BookInfo.objects.filter(heroinfo__hcomment__contains=&#39;丁&#39;)</code></pre></li><li>通过一类的条件查询多类的数据：<pre><code>  # 多类名.objects.filter(关联属性__一类名属性__条件名)  HeroInfo.objects.afilter(hbook__btitle=&#39;三体&#39;)</code></pre></li></ul></li></ul><h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><p>外键指向自身的属性，在查询时仍然按照一对多的关系查询。</p><pre><code># models.pyclass AreaInfo(model.Models):    atitle = model.CharFields(max_length=20)    aParent = models.Foreign(&#39;self&#39;, null=True, blank=True)# views.pydef areas(request):    area = AreaInfo.objects.get(atitle=&#39;广州&#39;)    parent = area.aParent    children = area.areainfo_set.all()</code></pre><h2 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h2><p>我们在查询中一直使用的 objects 其实是 django 自动生成的管理器 models.Manager() 类对象，我们也可以自定义，但是自定义管理器之后，django 便不会再自己生成 objects 管理器。</p><p>自定义分为两步：</p><p>（1）自定义一个管理器类，继承于 models.Manager()</p><p>（2）在具体的模型类中定义一个管理器类的对象。</p><p>自定义管理器类的应用场景：</p><p>（1）改变查询的结果集，比如调用 all 返回的是没有删除的图书的数据。</p><pre><code>class BookInfoManager(models.Manager):    def all(self):        books = super().all()        books = books.filter(isDelete=False)        return booksclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><p>（2）添加额外的方法使我们操作模型类对应的数据表。使用 self.model() 就可以创建一个根自定义管理器对应的模型类对象，这样作可以防止因为改换模型类的名字而相应也要改换管理器中的名字，避免了麻烦。</p><pre><code>class BookInfoManager(models.Manager):    def create_book(self, btitle, bupdate):        model_class = self.model        book = model_class()        book.btitle = btitle        book.bupdate = bupdate        book.save()        return bookclass BookInfo(models.Model):    objects = BookInfoManager()</code></pre><h2 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h2><p>django 默认生成的表名：<strong>应用名小写__模型类名小写</strong></p><p>元选项：需要在模型类中定义一个元类<code>Meta</code>，在里买年定义一个类属性 <code>db_table</code>就可以指定表名</p><pre><code>class BookInfo(model.Models):    class Meta:        db_table = &#39;new_sheet_name&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django的基本应用</title>
      <link href="/2020/07/30/django-de-ji-ben-ying-yong/"/>
      <url>/2020/07/30/django-de-ji-ben-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="项目与应用创建"><a href="#项目与应用创建" class="headerlink" title="项目与应用创建"></a>项目与应用创建</h2><pre><code>django-admin startproject test1  # 创建 test1 项目python37 manage.py startapp booktest  # 创建 booktest 应用</code></pre><ul><li>项目目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>settings.py</code> 项目的配置文件；</li><li><code>urls.py</code> 进行 url 路由的配置；</li><li><code>wsgi.py</code> web 服务器和 Django 交互的入口</li><li><code>manage.py</code> 项目的管理文件。</li></ol></li><li>应用目录结构<ol><li><code>__init__.py</code> 说明是一个 python 包；</li><li><code>model.py</code> 写和数据库相关的功能；</li><li><code>views.py</code> 接受请求，进行处理，与 M 和 T 进行交互，返回应答，定义处理函数，称为视图函数；</li><li><code>test.py</code> 写测试代码的文件；</li><li><code>admin.py</code> 网站后台管理相关的文件</li></ol></li></ul><p>还需要建立应用与项目之间的联系，需要对应用进行注册。<br>修改<code>settings.py</code>中的 INSTALLED_APPS 配置项，加入自己的应用名称即可。</p><pre><code>INSTALLED_APPS = (    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;booktest&#39;,  # 注册应用)</code></pre><h2 id="配置-mysql-数据库"><a href="#配置-mysql-数据库" class="headerlink" title="配置 mysql 数据库"></a>配置 mysql 数据库</h2><p>Django 自带的数据库是 sqlite 相对小型，在大项目中用的更多的是 oracle 和 mysql，所以要替换。</p><p>模型是对数据库的相关操作，利用 Django 配置 mysql 数据库，需要修改<code>settings.py</code>中的 DATABASE。</p><pre><code>DATABASES = {    &#39;default&#39;: {        # &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,          # &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),        &#39;NAME&#39;: &#39;qay&#39;,            # 数据库名称        &#39;USER&#39;: &#39;root&#39;,           # 登陆数据库的用户名        &#39;PASSWORD&#39;: &#39;qin200053&#39;,  # 登陆密码        &#39;HOST&#39;: &#39;localhost&#39;,      # 登陆地址        &#39;PORT&#39;: &#39;3306&#39;,           # 端口号，mysql默认端口号是3306    }}</code></pre><p>注意：django不会生成数据库，需要我们自己创建。</p><p>我的 Ubuntu 版本是20.04，mysql官网上只有8.0才支持20.04，于是我直接安装的 mariadb 暂时作为 mysql 的替代品，目前看来命令没什么区别，希望以后不会出什么bug。</p><pre><code>sudo apt-get mariadb-server mariadb-client  # 安装</code></pre><ul><li>开启关闭服务，登陆退出。<pre><code>  sercive mysql start  service mysql stop  sudo mysql -uroot </code></pre></li><li>避免使用 sudo 登陆,需要执行<code>sudo vim /etc/mysql/my.cnf</code>，然后添加如下语句，再重启服务即可。<pre><code>  [mysqld]  skip-grant-tables</code></pre></li><li>修改mysql密码。<pre><code>  mysql -uroot -p  use mysql   update user set authentication_string=password(&#39;xxxxxx&#39;) where User=&#39;root&#39;;</code></pre></li><li>创建新的数据库<pre><code>  mysql -uroot -p  show databases;  create database qay charset=utf8;  show databases; </code></pre></li></ul><p>处理完 mysql，在启动项目之前，需要<code>sudo pip37 install pymysql</code>，并在项目的<code>__init__.py</code>中加入如下语句，就可以了。</p><pre><code>import pymysqlpymysql.install_as_MySQLdb()</code></pre><h2 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h2><p>我们需要设计和数据库中表相对应的类，称为模型类，本质上就是在<code>models.py</code>中建立 class，其必须继承于 models.Model类。</p><pre><code>class BookInfo(models.Model):    &#39;&#39;&#39;图书模型类&#39;&#39;&#39;    # 图书名称，字符串，最长20    btitle = models.CharField(max_length=20)    # 出版日期，日期类型    bupdate = models.DateField()</code></pre><p>设计完模型类之后，将其生成为数据库中的表：</p><ul><li><p>生成迁移文件<code>python37 manage.py makemigrations</code>，文件生成在 migrations 文件夹中；</p></li><li><p>执行迁移生成表<code>python37 manage.py migrate</code>，这样去数据库里就能查看到了，创建的表名即为<code>应用名_类名</code>。</p></li><li><p>接下来就可以通过python语句，对数据进行操作了，利用 <code>python37 manage.py shell</code>进行操作：</p><pre><code>  &gt;&gt;&gt; from booktest.models import BookInfo  &gt;&gt;&gt; b = BookInfo()  &gt;&gt;&gt; b.btitle = &#39;三体&#39;  &gt;&gt;&gt; from datetime import date  &gt;&gt;&gt; b.bupdate = date(1990,1,1)  &gt;&gt;&gt; b.save()  # 通过 save 进行插入和修改  &gt;&gt;&gt; b_all = BookInfo.objects.all()   # 拿到所有实例，即表中所有条目，返回一个列表  &gt;&gt;&gt; b2 = BookInfo.objects.get(id=1)  # 拿到实例，可以借此查询  &gt;&gt;&gt; b_cond = BookInfo.objects.get(btitle=&#39;三体&#39;)  # 按条件查询  &gt;&gt;&gt; type(b2)  &lt;class &#39;booktest.models.BookInfo&#39;&gt;  &gt;&gt;&gt; b2.btitle  &#39;三体&#39;  &gt;&gt;&gt; b2.bupdate  datetime.date(1990,1,1)  &gt;&gt;&gt; b2.delete()  # 通过 delete 删除</code></pre></li></ul><pre><code>class HeroInfo(models.Model):    hname = models.CharField(max_length=20)    hgender = models.BooleanField(default=False)    hcomment = models.CharField(max_length=128)    # 关系属性 hbook，建立图书类和英雄人物类之间的一对多关系    hbook = models.ForeignKey(&#39;BookInfo&#39;)</code></pre><p>表之间存在关系。</p><ul><li><p>Models.ForeignKey 可以建立两个模型之间一对多的关系，django 在生成表的时候，就会在多的表中创建一列作为外键，建立两个表之间一对多的关系。关系属性对应的表的字段名格式为<code>关系属性名_id</code>。</p><p>  以上面的类作为例子，很多英雄可能都属于一本书，所以在‘多类’中添加关系属性，赋值时要赋‘一类’的实例，在实际的表中，<code>h</code>的属性<code>hbook_id</code>的值即为<code>b</code>的主键<code>id</code>值：</p><pre><code>  b = BookInfo()  h = HeroInfo()  h.hbook = b</code></pre></li><li><p>建立了关系之后，可以根据关系查询：</p><p>  由一查多：<code>b.heroinfo_set.all()</code><br>  由多查一：<code>h.hbook</code></p></li></ul><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><ul><li><p>修改<code>settings.py</code>，语言和时区本地化</p><pre><code>  LANGUAGE_CODE = &#39;zh_hans&#39;  TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre></li><li><p>创建管理员</p><pre><code>  python37 manage.py createsuperuser</code></pre></li><li><p>在<code>admin.py</code>中注册模型类</p><pre><code>  admin.site.register(BookInfo)  admin.site.register(HeroInfo)</code></pre></li><li><p>启动项目后在浏览器输入<code>http://127.0.0.1:8000/admnin</code></p></li><li><p>自定义管理页面，在 admin 中建立自定义管理类</p><pre><code>  class BookInfoAdmin(admin.ModelAdmin):      list_display = [&#39;id&#39;,&#39;btitle&#39;,&#39;bupdate&#39;]  admin.site.register(BookInfo, BookInfoAdmin)</code></pre></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在 Django 中，通过浏览器去请求一个页面时，使用视图函数来处理这个请求，视图函数处理之后，要给浏览器返回页面内容。</p><ul><li><p>在<code>views.py</code>中定义视图函数</p><p>  视图函数必须有一个参数<code>request</code>，处理之后需要返回一个 HttpResponse 的类对象。</p><pre><code>  # http://127.0.0.1:8000/index  def index(request):      return HttpResponse(&quot;nb!&quot;)</code></pre></li><li><p>配置项目路由</p><pre><code>  urlpatterns = [      url(r&#39;^admin/&#39;, include(admin.site.urls)),      url(r&#39;^&#39;, include(&#39;booktest.urls&#39;)),  ]</code></pre></li><li><p>配置应用路由，需要自己在应用目录下创建<code>urls.py</code></p><pre><code>  urlpatterns = [      url(r&#39;index$&#39;, views.index),  ]</code></pre></li><li><p>路由匹配过程</p><p>  当浏览器中输入<code>http://127.0.0.1:8000/index</code>，会自动除去前面的<code>http://127.0.0.1:8000/</code>用剩下的部分进行匹配，这里即<code>index</code>，先根据项目路由中的<code>urlpatterns</code>从上到下匹配，匹配成功后，根据后面的<code>include()</code>确定下一部去哪个应用进行匹配，这里即<code>booktest.urls</code>，然后再到<code>urlpatterns</code>从上到下匹配，直到匹配成功为止。</p><p>  匹配时严格根据正则规则匹配。（在新版本的django中函数 url 改成了函数 path，已经不需要正则表达式了）</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li>创建模板文件夹<code>templates</code>,并在<code>settings.py</code>的 TEMPLATES 中配置模板目录，通常可能有很多应用，所以在<code>templates</code>再以应用名建立文件夹<code>booktest</code><pre><code>  &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],</code></pre></li><li>使用模板文件分为三步：<ol><li>加载模板文件：去模板目录下获取html文件内容，得到一个模板对象；</li><li>定义模板上下文：像模板文件传递数据，传递时以键值对形式传递；</li><li>模板渲染：得到一个标准的html内容。<pre><code>def my_render(request, template_path, context_dict): temp = loader.get_template(&#39;booktest/index.html&#39;) context = RequestContext(request, {})  # 这里传了空字典 res_html = temp.render(context) return HttpResponse(res_html)</code></pre></li><li>以上三步可以用一个函数<code>render</code>完成:<pre><code>def index(request): # 传了两个变量，一个字符串一个列表 return render(request, &#39;booktest/index.html&#39;,           {&#39;content&#39;:&#39;hello world&#39;,&#39;list&#39;:list(range(1,10))})  </code></pre></li></ol></li><li>模板文件不仅仅时一个html文件，可以说有自己的语法，变量需要用两组花括号包裹，循环遍历或判断要用花括号和百分号包裹，下面给出一个例子：<pre><code>  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;mplate file&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;h1&gt;this is a template file&lt;/h1&gt;      use the template variable: &lt;br&gt;      {{ content }} &lt;br&gt;      use the list: &lt;br&gt;      {{ list }} &lt;br&gt;      for loop: &lt;br&gt;      &lt;ul&gt;          {% for i in list %}                &lt;li&gt;{{ i }}&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre></li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在视图函数的返回中，可以返回给定的一个模板，也可以根据 url 返回到另一个网址，这种就叫做重定向，下面就是在页面上显示书籍之后，新增或删除书籍之后仍返回 index 页面的例子，其中redirect 就是 HttpResponseRedirect 的一个简写。</p><p>注意，在html中有重定向，写到了链接时，为避免出错字符串要以<code>/</code>开头。</p><pre><code>def create(request):    b = BookInfo()    b.btitle = &#39;乡村教师&#39;    b.bupdate = date(1999,9,9)    b.save()    # return HttpResponse(&#39;ok&#39;)    return HttpResponseRedirect(&#39;/indexx&#39;)def delete(request, bid):    b = BookInfo.objects.get(id=bid)    b.delete()    return redirect(&#39;/indexx&#39;)</code></pre><h2 id="很简单的一个实例"><a href="#很简单的一个实例" class="headerlink" title="很简单的一个实例"></a>很简单的一个实例</h2><p>做一个很简单的实例，输入<code>http://127.0.0.1:8000/books</code>进入页面显示书名，点击书名能跳转到书所包含的人物信息。</p><ul><li><p>最重要的就是设计视图函数</p><pre><code>  def show_books(request):      books = BookInfo.objects.all()      return render(request, &#39;booktest/show_books.html&#39;,                  {&#39;books&#39;:books})  def detail(request, bid):      book = BookInfo.objects.get(id=bid)      heros = book.heroinfo_set.all()      return render(request, &#39;booktest/detail.html&#39;,          {&#39;book&#39;:book, &#39;heros&#39;:heros})</code></pre></li><li><p>配置各个页面的路由</p><pre><code>  urlpatterns = [      url(r&#39;^books$&#39;, views.show_books),      url(r&#39;^books/(\d+)$&#39;, views.detail),  ]</code></pre></li><li><p>编写模板呈现页面</p><pre><code>      # show_books.html      Information of Book is Followed:      &lt;ul&gt;          {% for book in books %}            &lt;li&gt;&lt;a href="/books/{{ book.id }}"&gt;{{ book.btitle }}&lt;/a&gt;&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;      # detail.html      &lt;h1&gt;{{ book.btitle }}&lt;/h1&gt;      Information of Heros is Followed:&lt;br&gt;      &lt;ul&gt;          {% for hero in heros %}                &lt;li&gt;{{ hero.hname }}--{{ hero.hcomment }}&lt;/li&gt;            {% empty %}                &lt;li&gt;no Information of Hero&lt;/li&gt;            {% endfor %}      &lt;/ul&gt;  </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从集群的部署</title>
      <link href="/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/"/>
      <url>/2020/07/29/redis-zhu-cong-ji-qun-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>主从，直观来说就是备份，当一个 redis 服务挂掉时，为了防止数据丢失或者不能使用，有一个副本来代替原来的服务。</p><h3 id="配置主"><a href="#配置主" class="headerlink" title="配置主"></a>配置主</h3><ul><li>查看当前主机 ip 地址 <code>ifconfig</code></li><li>修改 redis.conf 中的 bind <code>bind 192.168.xx.xx</code></li><li>重启 redis 服务 <code>redis-server redis.conf</code></li></ul><h3 id="配置从"><a href="#配置从" class="headerlink" title="配置从"></a>配置从</h3><ul><li>复制 redis.conf <code>sudo cp redis.conf ./slave.conf</code></li><li>修改 slave.conf 文件 <code>sudo vim slave.conf</code></li><li>编辑如下内容，注意端口号不能和主重复<pre><code>  bind 192.168.xx.xx  slaveof 192.168.xx.xx 6379  # 这是额外添加的一项  port 6378</code></pre></li><li>启动从服务 <code>sudo redis-server save.conf</code></li><li>查看主从关系 <code>redis-cli -h 192.168.xx.xx info Replication</code></li></ul><h3 id="主从配置下数据操作"><a href="#主从配置下数据操作" class="headerlink" title="主从配置下数据操作"></a>主从配置下数据操作</h3><p>与正常基本没有区别。</p><p>在主和从分别执行 info 命令查看输出信息后，进入主客户端，写数据；这时进入从客户端就可以读数据了。</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>集群，直观来讲就是好多 redis 服务作为一个整体对外工作，人多力量大。</p><p>集群分为两种，一种是软件集群，即只有一台电脑上面开启了很多 redis 服务，将这些服务集群；另一种是硬件集群，即有很多电脑，每台电脑上都有一个或很多 redis 服务，将所有服务集群。</p><p>集群中的主节点负责处理槽（存储数据），从节点则是主节点的复制品；</p><p>Redis集群将整个数据库分成16384个槽，数据库中的每个键都属于16384个槽中的其中一个；</p><p>集群中的每个主节点都可以负责0到16384个槽，当16384个槽都有节点在负责时，集群进入上线状态，可以执行客户端发送的数据命令；</p><p>可以在 conf 文件中更改槽的总数。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>试验时，在本机上开启6个服务做集群。</p><ul><li>创建 conf 目录</li><li>在 conf 目录下创建 7000.conf，编辑内容如下：<pre><code>  port 7000  bind 192.168.xx.xx  daemonize yes  # 作为守护进程运行  pidfile 7000.pid  # 运行后进程 id 写入这里  cluster-enabled yes  # 可以作为集群的节点  cluster-config-file 7000_node.conf  # 集群节点的配置文件  cluster-node-timeout 15000  # 连接集群节点的超时时间  appendonly yes  # 数据文件可追加</code></pre></li><li>同理创建7001，7002，7003，7004，7005</li><li>开启6个服务</li><li>用 redis-trib.rb 命令就可以创建集群，命令在源码包的 src 下，可以通过 cp 复制到 /usr/local/bin<pre><code>  redis-trib.rb create --replicas 1 192.168.101.145:7000 192.168.101.145:7001 192.168.101.145:7002 192.168.101.145:7003 192.168.101.145:7004 192.168.101.145:7005</code></pre></li></ul><p>如果没有报错，则说明集群建立成功了。</p><p>如果报错了。说明 ruby 的最新版本，按照如下方法解决。</p><pre><code>$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB$ curl -sSL https://get.rvm.io | bash -s stable$ source ~/.bashrc$ source ~/.bash_profile$ rvm list known$ rvm install 2.7.1 --disable-binary$ rvm use 2.7.1 --default$ rvm list$ gem install redis  # 最后安装 redis 集群接口</code></pre><p>执行完以上代码之后，再执行 redis-trib.rb 就可以了建立集群了。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装python</title>
      <link href="/2020/07/26/ubuntu-an-zhuang-python/"/>
      <url>/2020/07/26/ubuntu-an-zhuang-python/</url>
      
        <content type="html"><![CDATA[<p>由于 ubuntu20.04 自带的 python 版本是3.8，太高了，所以再安装 python3.7。</p><p>首先，安装好编译环境。</p><pre><code>sudo apt-get install -y liblzma-devsudo apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-devsudo apt-get install zlib1g-devsudo apt install libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev -ysudo apt install build-essential -y</code></pre><p>在官网下载安装包，并解压。</p><pre><code>sudo wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgzsudo tar -xzvf Python-3.7.1.tgzcd Python-3.7.1</code></pre><p>指定安装路径并编译安装，由于这里我安装在了 <code>/opt/</code> 下，所以之后和 python 相关的操作都要加 <code>sudo</code> 。</p><pre><code>sudo ./configure --enable-optimizations --prefix=/opt/python37/ sudo makesudo make install</code></pre><p>重点来了，安装完之后，在终端输入 python 还是会运行系统自带的版本，我们需要添加软连接。而在这里网上的教程都是把原来的指向 python3.8 的软连接 python3 清除，再新建软连接，经实测，这样做会导致后边引入包出现各种各样的错误。所以切记：<strong>一定不要动原系统自带的任何东西，不要怕麻烦，python 和 pip 都要新建立软连接</strong>，我这里命名为 python37, pip37，之后畅通无阻，没有任何报错。</p><p>安装完 python 之后，最好去 pypi 下载最新版本的 setuptools 和 pip，再各自的安装包中编译安装，这种方法最为保险，不会报错，另外 pip 建立软连接的问题和上述相同。</p><p>python 的基本工具已经安装完成，最后再安装一个虚拟环境建立工具即可，用 virtualenv 用惯了，这里就介绍它了。</p><p>安装用 pip 安装就好：</p><pre><code>sudo pip37 install virtualenv</code></pre><p>检查是否安装成功：</p><pre><code>virtualenv --version</code></pre><p>建立给定 python 解释器的虚拟环境：</p><pre><code>cd my_projectvirtualenv -p /usr/bin/python37 my_project_env</code></pre><p>启动虚拟环境：</p><pre><code>source my_project_env/bin/activate</code></pre><p>停止当前虚拟环境：</p><pre><code>deactivate</code></pre><p>顺便以 python 为例，记录一下修改环境变量的方法。</p><ol><li><p>方法一：</p><pre><code> export PATH=/opt/python37/bin:$PATH echo $PATH  # 查看配置结果</code></pre><p> <strong>生效方法</strong>：立即生效</p><p> <strong>有效期限</strong>：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="2"><li><p>方法二：<br> 修改 .bashrc 文件:</p><pre><code> vim ~/.bashrc</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：（有以下两种）</p><p> (1) 关闭当前终端窗口，重新打开一个新终端窗口就能生效</p><p> (2) 输入“source ~/.bashrc”命令，立即生效</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：仅对当前用户</p></li></ol><ol start="3"><li><p>方法三:<br> 通过修改 profile 文件:</p><pre><code> vim /etc/profile</code></pre><p> 在最后一行添上：<code>export PATH=/opt/python37/bin:$PATH</code></p><p> <strong>生效方法</strong>：系统重启</p><p> <strong>有效期限</strong>：永久有效</p><p> <strong>用户局限</strong>：对所有用户</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ubuntu系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库基本操作</title>
      <link href="/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/"/>
      <url>/2020/07/24/redis-shu-ju-ku-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="redis下载安装"><a href="#redis下载安装" class="headerlink" title="redis下载安装"></a>redis下载安装</h2><p>依次执行以下命令：</p><pre><code>$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar -zxvf redis-3.2.8.tar.gz$ sudo mv ./redis-3.2.8 /usr/local/redis$ cd /usr/local/redis$ sudo make$ sudo make test$ sudo make install</code></pre><p>安装完之后，查看 <code>/usr/local/bin</code>，如果有如下即安装成功。</p><pre><code>-rwxr-xr-x 1 root root 3344600 7月  24 14:38 redis-benchmark  # redis性能测试工具-rwxr-xr-x 1 root root   35872 7月  24 14:38 redis-check-aof  # AOF文件修复工具-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-check-rdb  # RDB文件修复工具-rwxr-xr-x 1 root root 3564272 7月  24 14:38 redis-cli  # redis命令行客户端lrwxrwxrwx 1 root root      12 7月  24 14:38 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 6771608 7月  24 14:38 redis-server  # redis服务器</code></pre><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>安装完成之后，会在 redis 文件夹爱中产生一个 <code>redis.conf</code> 配置文件，把它移到 <code>/etc/redis/</code> 中,修改其中内容进行配置。</p><pre><code> $ sudo cp redis.conf /etc/redis</code></pre><p>配置文件中需要注意的如下（修改过后）：</p><pre><code>bind 127.0.0.1                             # 默认绑定ip  port 6379                                  # 默认端口daemonize yes                              # 是否为守护进程（默认为no）logfile &quot;/var/log/redis/redis-server.log&quot;  # 日志文件（需要新建）databases 16                               # 默认16个数据库，编号0-15dbfilename dump.rdb                        # 数据文件dir /var/lib/redis                         # 数据文件存储路径（需要新建）slaveof                                    # 主从配置</code></pre><h2 id="redis服务端和客户端的启动"><a href="#redis服务端和客户端的启动" class="headerlink" title="redis服务端和客户端的启动"></a>redis服务端和客户端的启动</h2><p>服务端命令为 <code>redis-server</code>,<code>redis-server --help</code> 可查看帮助文档。<br>启动与关闭服务器如下：</p><pre><code>$ sudo redis-server /etc/redis/redis.conf  # 指定加载的配置文件，启动服务器$ ps aux | grep redis                      # 查看进程pid$ sudo kill -9 pid                         # 杀死服务器，即关闭</code></pre><p>客户端命令为 <code>redis-cli</code>,<code>redis-cli --help</code> 可查看帮助文档。<br>直接输入 <code>redis-cli</code> 即可连接服务端，输入 <code>ping</code> 起到检查连接的作用。</p><pre><code>$ redis-cli127.0.0.1:6379&gt; pingPONG</code></pre><p>利用 <code>select</code> 命令切换制定数据库，如：</p><pre><code>select 5</code></pre><h1 id="redis数据操作"><a href="#redis数据操作" class="headerlink" title="redis数据操作"></a>redis数据操作</h1><p><a href="doc.redisfans.com">redis命令大全</a> 很多命令可以去查找</p><p>以下代码有公式形式，匹配例子。</p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>设置的健不存在则添加，存在则修改。</p><ul><li>设置键值<pre><code>  set key value  set name itcast</code></pre></li><li>设置键值及过期时间，以秒为单位<pre><code>  setex key seconds value  setex aa 3 aa</code></pre></li><li>设置多个键值<pre><code>  mset key1 value1 key2 value2 ...  mset a1 python a2 java a3 c</code></pre></li><li>追加值<pre><code>  append key value  append a1 haha</code></pre></li><li>根据键获取值，如果不存在则返回 <code>nil</code> <pre><code>  get key  get name</code></pre></li><li>获取多个键的值<pre><code>  mget key1 key2 ...  mget a1 a2 a3</code></pre><h2 id="键命令"><a href="#键命令" class="headerlink" title="键命令"></a>键命令</h2></li><li>查找键，参数支持正则表达式<pre><code>  keys pattern  keys *       # 查看所有键  keys ‘a*’    # 包含 a 的键</code></pre></li><li>判断键是否存在，存在返回1，否则返回0<pre><code>  exists key1  exists a1</code></pre></li><li>查看对应的值的类型<pre><code>  type key  type a1</code></pre></li><li>删除键及对应的值<pre><code>  del key1 key2 ...   del a2 a3</code></pre></li><li>设置过期时间，以秒为单位<pre><code>  expire key seconds  expire &#39;a1&#39; 3</code></pre></li><li>查看有效时间<pre><code>  ttl key  setex bb 10 bb  ttl bb</code></pre></li></ul><h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>hash 用于存储对象，对象的结构为属性，值。值的类型为string。</p><ul><li>设置单个属性<pre><code>  hset key field value  hset user name itheima  # 如果报错，则表示为数据库快照，可执行下面命令使数据持久化  config set stop-writes-on-bgsave-error no</code></pre></li><li>设置多个属性<pre><code>  set key field1 value1 field2 value2  set u2 name itcast age 11</code></pre></li><li>获取指定键（对象）所有的属性<pre><code>  hkeys key  hkeys u2</code></pre></li><li>获取一个属性的值<pre><code>  hget key field  hget u2 name</code></pre></li><li>获取多个属性的值<pre><code>  hmget key field1 field2  hmget u2 name age</code></pre></li><li>获取所有属性的值<pre><code>  hvals key  hvals u2</code></pre></li><li>删除整个hash键及值，使用  <code>del</code> 命令</li><li>删除属性，属性对应的值会被一起删除<pre><code>  hdel key field1 field2 ...  hdel u2 age</code></pre></li></ul><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p>列表的元素类型为 <code>string</code>，按照插入顺序排序。</p><ul><li>在左侧插入数据<pre><code>  lpush key value1 value2 ...  lpush a1 a b c</code></pre></li><li>在右侧插入数据<pre><code>  rpush key value1 value2 ...  rpush a1 0 1</code></pre></li><li>在指定元素的前或后插入新元素<pre><code>  linsert key before或after 现有元素 新元素  linsert a1 before b 3</code></pre></li><li>获取列表里制定范围内的元素<pre><code>  lrange key start stop  lrange a1 0 -1</code></pre></li><li>设置指定索引位置的元素值<pre><code>  lset key index value  lset a 1 z</code></pre></li><li>删除指定元素<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>irem key count value</code></pre></li></ul></li></ul><h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p>无序集合，元素为 string 类型， 唯一性，不重复。对于集合没有修改操作。</p><ul><li>添加元素<pre><code>  sadd key member1 member2 ...  sadd a3 zhangsan sili wangwu</code></pre></li><li>返回所有元素<pre><code>  smembers key  smember a3</code></pre></li><li>删除指定元素<pre><code>  srem key memebr1  srem a3 wangwu</code></pre></li></ul><h2 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h2><p>有序集合，元素为 string 类型， 唯一性，不重复。每个元素都会关联一个double类型的score，表示权重。通过权重将元素从小到大排序，和 set 一样没有修改操作。</p><ul><li>添加元素<pre><code>  zadd key score1 member1 score2 member2 ...  sadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</code></pre></li><li>返回指定范围内元素<pre><code>  zrange keyy start stop  zrange a4 0 -1</code></pre></li><li>返回 score 值在 min 和 max 之间的元素（闭区间）<pre><code>  zrangebyscore key min max  zrangebyscore a4 5 6</code></pre></li><li>查看某 member 的 score 值<pre><code>  zscore key member  zscore a4 zhangsan</code></pre></li><li>萨和年初指定元素<pre><code>  zrem key member1 member2 ...  zrem a4 zhangsan</code></pre></li><li>删除 score 值在 min 和 max 之间的元素（闭区间）<ul><li>将列表中前 count 次出现的值为 value 的元素移除</li><li>count &gt; 0; 从头往后移除</li><li>count &lt; 0; 从后往头移除</li><li>count = 0; 全移除<pre><code>zremrangebyscore key min maxzremrangebyscore a4 5 6</code></pre></li></ul></li></ul><h1 id="redis与python的交互"><a href="#redis与python的交互" class="headerlink" title="redis与python的交互"></a>redis与python的交互</h1><p><a href="python.jobbole.com">redis.py参考文档</a></p><p>StrictRedis 对象方法能操作 string 类型</p><pre><code>sr = StrictRedis(host = &#39;localhost&#39;, port = 6379, db = 0)# 上述都为默认值，可简写sr = StrictRedis()</code></pre><p>根据不同的类型，拥有不同的实例方法可以调用，与前面的 redis 命令对应，方法的参数与命令的参数也一致。</p><h2 id="查看rdb文件"><a href="#查看rdb文件" class="headerlink" title="查看rdb文件"></a>查看rdb文件</h2><p>redis存储下来的数据文件是 <code>dump.rdb</code>，用vim打开是一堆乱码，在个github上发现了，查看rdb文件的工具。<a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools</a> 执行以下命令，可以以json形式查看数据。</p><pre><code>rdb -c json dump.rdb</code></pre><p>由于rdb是一种快照备份，在客户端修改数据过后，不会立即在dump.rdb中显示出来，若想立刻看到，需要在客户端执行<code>BGSAVE</code>异步后台保存，再查看就可以了。注：conf文件中有快照的配置，如下：</p><pre><code># 如果不备份就将 下边3个参数注释掉# 刷新快照到硬盘，必须满足两者要求才会触发save 900 1     # 即900秒之后至少1个关键字发生变化save 300 10    # 必须是300秒之后至少10个关键字发生变化save 60 10000  # 必须是60秒之后10000个关键字发生变化</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10+Ubuntu20.04双系统搭建过程</title>
      <link href="/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/"/>
      <url>/2020/07/24/win10-ubuntu20-04-shuang-xi-tong-da-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>鬼知道我这两天重启了多少次电脑，那个小洞都快被我插烂了。。。</p><hr><p>因为有需求要用Ubuntu系统，之前用虚拟机实在是太卡了，索性下定决心装上双系统，总共用了将近2天时间才搞定，下面记录一下装机过程。（要是放图就太多了，不放了，步骤很详细）</p><hr><h2 id="提前准备的东西："><a href="#提前准备的东西：" class="headerlink" title="提前准备的东西："></a>提前准备的东西：</h2><ol><li>注意在装双系统之前要有一个空的盘和一和空的U盘，装机的过程会使之格式化，所以有重要文件一定要备份好。</li><li>下载一个U盘引导盘制作工具 rufus 软件。</li><li>下载好想下载的系统安装包，可以去官网下载或者找阿里云也可，我下的是最新版的 ubuntu20.04，是iso镜像文件。</li></ol><hr><h2 id="一-修改BIOS"><a href="#一-修改BIOS" class="headerlink" title="一. 修改BIOS"></a>一. 修改BIOS</h2><p>首先要进入 BIOS，不同电脑进入的方式可能会不一样，开机时按 <code>F12</code> 或 <code>F2</code> 可能会进入，但是我试了很多按法都没进去，索性直接在关机时用针插入电脑侧边的小洞（有恢复图标），最好找长一点的，太短了会没有反应。打开 BIOS 之后要做的是允许引导写入，做法是进入 BIOS，然后进入 Security，将 Secure Boot 从 Enable 改称 Disable。最后按 <code>F10</code>，保存自动重启电脑。</p><h2 id="二-制作引导盘"><a href="#二-制作引导盘" class="headerlink" title="二. 制作引导盘"></a>二. 制作引导盘</h2><p>插上空的U盘，打开 rufus 软件，在设备处选择自己插的U盘，在引导类型选择处选择系统安装包，目标系统类型 BIOS 或 UEFI，然后就可以开始了，然后点击OK之后，引导盘就制做好了。</p><h2 id="三-利用引导盘装系统"><a href="#三-利用引导盘装系统" class="headerlink" title="三. 利用引导盘装系统"></a>三. 利用引导盘装系统</h2><p>在关机的情况下插上U盘，同样插那个小孔，这次选择启动菜单 boot menu，选择用U盘来启动，进入 Ubuntu 。然后就按引导的步骤来，选中文，地区正常安装等等，注意在选择安装类型的时候选其他选项。这样我们就会自己来进行分区了。我们能看到空闲是非常小的。如果能到达这一步了，说明没什么问题，这个时候重启电脑，进入 Win10，终于要把 ubuntu 装进电脑了，我这里是装进了空的E盘。</p><p>进入 Win10 之后，右击此电脑，选择管理，进入磁盘管理，能看到电脑有几个盘有哪些空间，右击想装的盘，我这里是E盘，删除磁盘，删除之后就会显示有好大的空间没有分配了。而这些空间就是我们要重新分配的。</p><p>重启进入 ubuntu，回到 ubuntu 分区那一步骤，我们能看到空闲空间变得很大。我们就要分配这些空间，每次分区都先点击空闲，再点击加号。由于只讲步骤，这里先不谈 linux 的分区，下面几个分区一定不要弄错。</p><ol><li>建立 swap 交换空间，取8G，设置为主分区和空间起始位置；</li><li>建立 EFI 系统分区，取300M，设置为逻辑分区和空间起始位置；</li><li>建立 /home 分区，取150G，设置为逻辑分区和空间起始位置；</li><li>建立 /usr 分区，取100G，设置为逻辑分区和空间起始位置；</li><li>建立 / 分区，取剩下所有，设置为逻辑分区和空间起始位置。</li></ol><p>安装启动引导器的设备选 /dev/sda4，接下来就可以继续安装，按提示重启电脑了。如果设备理想兼容的话，再次重启就能进入系统选择了。然而我遇到了ubuntu系统卡紫屏的问题。。。</p><h2 id="四-修改内核参数解决卡紫屏"><a href="#四-修改内核参数解决卡紫屏" class="headerlink" title="四. 修改内核参数解决卡紫屏"></a>四. 修改内核参数解决卡紫屏</h2><p>查资料是显卡驱动的问题，之前用的 NVIDIA 显卡驱动，和新系统不适配。</p><p>紫屏时只能按电源关机，再重启进入引导页面时，按 <code>e</code> 键进入 <code>grub</code> 页面，在其中找到开头是linux的一行，再最后加上 <code>nomodeset</code> 这样能暂时禁用所有显卡驱动，<code>F10</code> 保存退出，就能正常打开ubuntu系统了，别忘了系统要更新，输入以下命令即可：</p><pre><code> $ sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre><p>更新之后最好再重启一下电脑，这时还得加上 <code>nomodeset</code> 才能打开，打开后搜索 <code>drivers</code> 就能看到额外驱动标签页，打开之后就能看到有很多可选择的驱动，而默认的并不是 NVIDIA，所以我们改称 NVIDIA，这样就不用每次开机都要修改内核参数了。</p><h2 id="五-两个小问题"><a href="#五-两个小问题" class="headerlink" title="五. 两个小问题"></a>五. 两个小问题</h2><ol><li><p>刚装完之后会遇到每次开机直接进入windows的情况</p><p> 查资料得知，因为 Windows 现在是快速启动， Windows8以上的系统关机实际上不是以前的关机，而是休眠，因此下次开机实际上是从休眠中恢复，因此是直接进入 Windows 。因此把快速启动关掉就可以了。</p></li><li><p>打开 ubuntu 再进入 Win10，总会比正常时间差 8 个小时</p><p> 查资料得知，Windows 和 Ubuntu 的时间设置方式是不一样的，造成了这种错误。在 Ubuntu 中把计算机硬件时间改成系统显示的时间，即禁用Ubuntu的UTC：</p><pre><code> timedatectl set-local-rtc 1 --adjust-system-clock</code></pre><p> 然后再重启电脑进入 Windows 修改时间即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ubuntu系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
